<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
<title>Binary AST</title>
<pre class=metadata>
status: proposal
contributors: Shu-yu Guo, David Teller, Ecma International
</pre>
<emu-intro id="binast-intro">
  <h1>Binary AST</h1>
  <p>The binary AST is isomorphic to ECMA-262 Syntactic Grammar. That is, an instance of a production of the binary AST grammar, or a <dfn>binary AST Node</dfn>, corresponds to some Parse Node in the ECMA-262 syntactic grammar. This document specifies the following things.</p>
  <ol>
    <li>The tree grammar itself described in IDL and its well-formedness.</li>
    <li>The transformation abstract operation Ecmaify(_binaryAST_) from binary AST Nodes to Parse Nodes by case analysis.</li>
    <li>TODO: The similarity Static Semantics ParseNodesAreSimilar.</li>
    <li>The evaluation of binary AST input.</li>
  </ol>
  <p>A compliant binary AST Encoder, for a source text that matches either the |Script| or |Module| goal symbol to produce a Parse Node _N_, must produce a binary AST Node _B_ such that ParseNodesAreSimilar(Ecmaify(_B_), _N_) is *true*.</p>
  <p>The inverse of Ecmaify, Unecmaify, is not specified here. The inverse transform is the encoding of Parse Nodes. For _B_ and _N_ as above, for all _M_ such that ParseNodesAreSimilar(_M_, _N_) is *true*, Unecmaify(_M_) is _B_.</p>
</emu-intro>

<emu-clause id="binast-tree-grammar">
  <h1>Tree Grammar</h1>
  <p>This section is derived from <a href="https://github.com/shapesecurity/shift-spec/blob/es2017/spec.idl">Shift AST Spec</a> and parts are Copyright 2014-2017 Shape Security, Inc.</p>
  <p>Unlike the Shift AST spec, interface types are not used to inherit fields to control over ordering of fields. Type hierarchies that are not used to discriminate are collapsed to make space costs simple. Nor are they used to discriminate types, for which explicitly discriminated unions types are used.</p>
  <emu-note>Whereas Shift AST's design principle is ease of search-and-replace of node types, binary AST's design principle is ease of verification and ease of associating different behaviors with syntactically different (but possibly lexically similar) productions.</emu-note>
  <p>The grammar is presented in WebIDL with the `[TypeIndicator]` and `[NonEmpty]` extensions per Shift AST spec. The `[Lazy]` extension serves as a hint to the surface encoding that the `[Lazy]` attribute should be skippable in the byte stream in constant time. The `typedefs` of `or` types are to be read as recursive sum types. In text below, the "is a `Foo`" prose is shorthand for checking the node's `type` attribute being equal to `"Foo"`.</p>

  <pre><code class="language-webidl">
// Type aliases and enums.

typedef FrozenArray&lt;(SpreadElement or Expression)> Arguments;
typedef DOMString string;
typedef string Identifier;
typedef string IdentifierName;
typedef string Label;

enum VariableDeclarationKind {
  "var",
  "let",
  "const"
};

enum CompoundAssignmentOperator {
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "**=",
  "&lt;&lt;=",
  ">>=",
  ">>>=",
  "|=",
  "^=",
  "&="
};

enum BinaryOperator {
  ",",
  "||",
  "&&",
  "|",
  "^",
  "&",
  "==",
  "!=",
  "===",
  "!==",
  "<",
  "<=",
  ">",
  ">=",
  "in",
  "instanceof",
  "<<",
  ">>",
  ">>>",
  "+",
  "-",
  "*",
  "/",
  "%",
  "**",
};

enum UnaryOperator {
  "+",
  "-",
  "!",
  "~",
  "typeof",
  "void",
  "delete"
};

enum UpdateOperator {
  "++",
  "--"
};

enum AssertedDeclaredKind {
  "var",
  "non-const lexical",
  "const lexical"
};

// deferred assertions

interface AssertedDeclaredName {
  attribute IdentifierName name;
  attribute AssertedDeclaredKind kind;
  attribute boolean isCaptured;
}

interface AssertedBoundName {
  attribute IdentifierName name;
  attribute boolean isCaptured;
}

interface AssertedBlockScope {
  attribute FrozenArray&lt;AssertedDeclaredName&gt; declaredNames;
  attribute boolean hasDirectEval;
};

interface AssertedScriptGlobalScope {
  attribute FrozenArray&lt;AssertedDeclaredName&gt; declaredNames;
  attribute boolean hasDirectEval;
};

interface AssertedVarScope {
  attribute FrozenArray&lt;AssertedDeclaredName&gt; declaredNames;
  attribute boolean hasDirectEval;
};

interface AssertedParameterScope {
  attribute FrozenArray&lt;AssertedBoundName&gt; boundNames;
  attribute boolean hasDirectEval;
  attribute boolean isSimpleParameterList;
};

interface AssertedBoundNamesScope {
  attribute FrozenArray&lt;AssertedBoundName&gt; boundNames;
  attribute boolean hasDirectEval;
};

// nodes

interface Node {
  [TypeIndicator] readonly attribute Type type;
};

typedef (Script or Module) Program;

typedef (DoWhileStatement or
         ForInStatement or
         ForOfStatement or
         ForStatement or
         WhileStatement)
        IterationStatement;

typedef (Block or
         BreakStatement or
         ContinueStatement or
         ClassDeclaration or
         DebuggerStatement or
         EmptyStatement or
         ExpressionStatement or
         FunctionDeclaration or
         IfStatement or
         IterationStatement or
         LabelledStatement or
         ReturnStatement or
         SwitchStatement or
         SwitchStatementWithDefault or
         ThrowStatement or
         TryCatchStatement or
         TryFinallyStatement or
         VariableDeclaration or
         WithStatement)
        Statement;

typedef (LiteralBooleanExpression or
         LiteralInfinityExpression or
         LiteralNullExpression or
         LiteralNumericExpression or
         LiteralStringExpression)
        Literal;

typedef (Literal or
         LiteralRegExpExpression or
         ArrayExpression or
         ArrowExpression or
         AssignmentExpression or
         BinaryExpression or
         CallExpression or
         CompoundAssignmentExpression or
         ComputedMemberExpression or
         ConditionalExpression or
         ClassExpression or
         FunctionExpression or
         IdentifierExpression or
         NewExpression or
         NewTargetExpression or
         ObjectExpression or
         UnaryExpression or
         StaticMemberExpression or
         TemplateExpression or
         ThisExpression or
         UpdateExpression or
         YieldExpression or
         YieldStarExpression or
         AwaitExpression)
        Expression;

typedef (ComputedPropertyName or
         LiteralPropertyName)
        PropertyName;

typedef (Method or Getter or Setter) MethodDefinition;

typedef (MethodDefinition or
         DataProperty or
         ShorthandProperty)
        ObjectProperty;

typedef (ExportAllFrom or
         ExportFrom or
         ExportLocals or
         ExportDefault or
         Export)
        ExportDeclaration;

typedef (ImportNamespace or Import) ImportDeclaration;

typedef (EagerFunctionDeclaration or
         LazyFunctionDeclaration) FunctionDeclaration;

typedef (EagerFunctionExpression or
         LazyFunctionExpression) FunctionExpression;

typedef (EagerMethod or LazyMethod) Method;

typedef (EagerGetter or LazyGetter) Getter;

typedef (EagerSetter or LazySetter) Setter;

typedef (EagerArrowExpressionWithFunctionBody or
         LazyArrowExpressionWithFunctionBody or
         EagerArrowExpressionWithExpression or
         LazyArrowExpressionWithExpression) ArrowExpression;

// bindings

interface BindingIdentifier : Node {
  attribute Identifier name;
};

typedef (ObjectBinding or
         ArrayBinding)
        BindingPattern;
typedef (BindingPattern or
         BindingIdentifier)
        Binding;

typedef (AssignmentTargetIdentifier or
         ComputedMemberAssignmentTarget or
         StaticMemberAssignmentTarget)
        SimpleAssignmentTarget;
typedef (ObjectAssignmentTarget or
         ArrayAssignmentTarget)
        AssignmentTargetPattern;
// `DestructuringAssignmentTarget`
typedef (AssignmentTargetPattern or
         SimpleAssignmentTarget)
        AssignmentTarget;

// `FormalParameter`
typedef (Binding or
         BindingWithInitializer)
        Parameter;

interface BindingWithInitializer : Node {
  attribute Binding binding;
  attribute Expression init;
};

interface AssignmentTargetIdentifier : Node {
  attribute Identifier name;
};

interface ComputedMemberAssignmentTarget : Node {
  // The object whose property is being assigned.
  attribute (Expression or Super) _object;
  // The expression resolving to the name of the property to be accessed.
  attribute Expression expression;
};

interface StaticMemberAssignmentTarget : Node {
  // The object whose property is being assigned.
  attribute (Expression or Super) _object;
  // The name of the property to be accessed.
  attribute IdentifierName property;
};

// `ArrayBindingPattern`
interface ArrayBinding : Node {
  // The elements of the array pattern; a null value represents an elision.
  attribute FrozenArray&lt;(Binding or BindingWithInitializer)?&gt; elements;
  attribute Binding? rest;
};

// `SingleNameBinding`
interface BindingPropertyIdentifier : Node {
  attribute BindingIdentifier binding;
  attribute Expression? init;
};

// `BindingProperty :: PropertyName : BindingElement`
interface BindingPropertyProperty : Node {
  attribute PropertyName name;
  attribute (Binding or BindingWithInitializer) binding;
};

typedef (BindingPropertyIdentifier or
         BindingPropertyProperty)
        BindingProperty;

interface ObjectBinding : Node {
  attribute FrozenArray&lt;BindingProperty&gt; properties;
};

// This interface represents the case where the initializer is present in
// `AssignmentElement :: DestructuringAssignmentTarget Initializer_opt`.
interface AssignmentTargetWithInitializer : Node {
  attribute AssignmentTarget binding;
  attribute Expression init;
};

// `ArrayAssignmentPattern`
interface ArrayAssignmentTarget : Node {
  // The elements of the array pattern; a null value represents an elision.
  attribute FrozenArray&lt;(AssignmentTarget or AssignmentTargetWithInitializer?)&gt; elements;
  attribute AssignmentTarget? rest;
};

// `AssignmentProperty :: IdentifierReference Initializer_opt`
interface AssignmentTargetPropertyIdentifier : Node {
  attribute AssignmentTargetIdentifier binding;
  attribute Expression? init;
};

// `AssignmentProperty :: PropertyName : Node`
interface AssignmentTargetPropertyProperty : Node {
  attribute PropertyName name;
  attribute (AssignmentTarget or AssignmentTargetWithInitializer) binding;
};

typedef (AssignmentTargetPropertyIdentifier or
         AssignmentTargetPropertyProperty)
        AssignmentTargetProperty;

// `ObjectAssignmentPattern`
interface ObjectAssignmentTarget : Node {
  attribute FrozenArray&lt;AssignmentTargetProperty&gt; properties;
};


// classes

interface ClassExpression : Node {
  attribute BindingIdentifier? name;
  attribute Expression? super;
  attribute FrozenArray&lt;ClassElement&gt; elements;
};

interface ClassDeclaration : Node {
  attribute BindingIdentifier name;
  attribute Expression? super;
  attribute FrozenArray&lt;ClassElement&gt; elements;
};

interface ClassElement : Node {
  // True iff `IsStatic` of ClassElement is true.
  attribute boolean isStatic;
  attribute MethodDefinition method;
};


// modules

interface Module : Node {
  attribute AssertedVarScope scope;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute FrozenArray&lt;(ImportDeclaration or ExportDeclaration or Statement)&gt; items;
};

// An `ImportDeclaration` not including a namespace import.
interface Import : Node {
  attribute string moduleSpecifier;
  // `ImportedDefaultBinding`, if present.
  attribute BindingIdentifier? defaultBinding;
  attribute FrozenArray&lt;ImportSpecifier&gt; namedImports;
};

// An `ImportDeclaration` including a namespace import.
interface ImportNamespace : Node {
  attribute string moduleSpecifier;
  // `ImportedDefaultBinding`, if present.
  attribute BindingIdentifier? defaultBinding;
  attribute BindingIdentifier namespaceBinding;
};

interface ImportSpecifier : Node {
  // The `IdentifierName` in the production `ImportSpecifier :: IdentifierName as ImportedBinding`;
  // absent if this specifier represents the production `ImportSpecifier :: ImportedBinding`.
  attribute IdentifierName? name;
  attribute BindingIdentifier binding;
};

// `export * FromClause;`
interface ExportAllFrom : Node {
  attribute string moduleSpecifier;
};

// `export ExportClause FromClause;`
interface ExportFrom : Node {
  attribute FrozenArray&lt;ExportFromSpecifier&gt; namedExports;
  attribute string moduleSpecifier;
};

// `export ExportClause;`
interface ExportLocals : Node {
  attribute FrozenArray&lt;ExportLocalSpecifier&gt; namedExports;
};

// `export VariableStatement`, `export Declaration`
interface Export : Node {
  attribute (FunctionDeclaration or ClassDeclaration or VariableDeclaration) declaration;
};

// `export default HoistableDeclaration`,
// `export default ClassDeclaration`,
// `export default AssignmentExpression`
interface ExportDefault : Node {
  attribute (FunctionDeclaration or ClassDeclaration or Expression) body;
};

// `ExportSpecifier`, as part of an `ExportFrom`.
interface ExportFromSpecifier : Node {
  // The only `IdentifierName in `ExportSpecifier :: IdentifierName`,
  // or the first in `ExportSpecifier :: IdentifierName as IdentifierName`.
  attribute IdentifierName name;
  // The second `IdentifierName` in `ExportSpecifier :: IdentifierName as IdentifierName`,
  // if that is the production represented.
  attribute IdentifierName? exportedName;
};

// `ExportSpecifier`, as part of an `ExportLocals`.
interface ExportLocalSpecifier : Node {
  // The only `IdentifierName in `ExportSpecifier :: IdentifierName`,
  // or the first in `ExportSpecifier :: IdentifierName as IdentifierName`.
  attribute IdentifierExpression name;
  // The second `IdentifierName` in `ExportSpecifier :: IdentifierName as IdentifierName`, if present.
  attribute IdentifierName? exportedName;
};


// property definition

// `MethodDefinition :: PropertyName ( UniqueFormalParameters ) { FunctionBody }`,
// `GeneratorMethod :: * PropertyName ( UniqueFormalParameters ) { GeneratorBody }`,
// `AsyncMethod :: async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody }`
interface EagerMethod : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute PropertyName name;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute FunctionOrMethodContents contents;
};
interface LazyMethod : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute PropertyName name;
  attribute FrozenArray&lt;Directive&gt; directives;
  [Lazy] attribute FunctionOrMethodContents contents;
};

// `get PropertyName ( ) { FunctionBody }`
interface EagerGetter : Node {
  attribute PropertyName name;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute GetterContents contents;
};
interface LazyGetter : Node {
  attribute PropertyName name;
  attribute FrozenArray&lt;Directive&gt; directives;
  [Lazy] attribute GetterContents contents;
};

interface GetterContents : Node {
  attribute boolean isThisCaptured;
  attribute AssertedVarScope bodyScope;
  attribute FunctionBody body;
};

// `set PropertyName ( PropertySetParameterList ) { FunctionBody }`
interface EagerSetter : Node {
  attribute PropertyName name;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute SetterContents contents;
};
interface LazySetter : Node {
  attribute PropertyName name;
  attribute FrozenArray&lt;Directive&gt; directives;
  [Lazy] attribute SetterContents contents;
};

interface SetterContents : Node {
  attribute boolean isThisCaptured;
  attribute AssertedParameterScope parameterScope;
  attribute Parameter param;
  attribute AssertedVarScope bodyScope;
  attribute FunctionBody body;
};

// `PropertyDefinition :: PropertyName : AssignmentExpression`
interface DataProperty : Node {
  attribute PropertyName name;
  // The `AssignmentExpression`.
  attribute Expression expression;
};

// `PropertyDefinition :: IdentifierReference`
interface ShorthandProperty : Node {
  // The `IdentifierReference`.
  attribute IdentifierExpression name;
};

interface ComputedPropertyName : Node {
  attribute Expression expression;
};

// `LiteralPropertyName`
interface LiteralPropertyName : Node {
  attribute string value;
};


// literals

// `BooleanLiteral`
interface LiteralBooleanExpression : Node {
  attribute boolean value;
};

// A `NumericLiteral` for which the Number value of its MV is positive infinity.
interface LiteralInfinityExpression : Node { };

// `NullLiteral`
interface LiteralNullExpression : Node { };

// `NumericLiteral`
interface LiteralNumericExpression : Node {
  attribute double value;
};

// `RegularExpressionLiteral`
interface LiteralRegExpExpression : Node {
  attribute string pattern;
  attribute string flags;
};

// `StringLiteral`
interface LiteralStringExpression : Node {
  attribute string value;
};


// other expressions

// `ArrayLiteral`
interface ArrayExpression : Node {
  // The elements of the array literal; a null value represents an elision.
  attribute FrozenArray&lt;(SpreadElement or Expression)?&gt; elements;
};

// `ArrowFunction`,
// `AsyncArrowFunction`
interface EagerArrowExpressionWithFunctionBody : Node {
  // True for `AsyncArrowFunction`, false otherwise.
  attribute boolean isAsync;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute ArrowExpressionContentsWithFunctionBody contents;
};
interface LazyArrowExpressionWithFunctionBody : Node {
  // True for `AsyncArrowFunction`, false otherwise.
  attribute boolean isAsync;
  attribute FrozenArray&lt;Directive&gt; directives;
  [Lazy] attribute ArrowExpressionContentsWithFunctionBody contents;
};
interface EagerArrowExpressionWithExpression : Node {
  // True for `AsyncArrowFunction`, false otherwise.
  attribute boolean isAsync;
  attribute ArrowExpressionContentsWithExpression contents;
};
interface LazyArrowExpressionWithExpression : Node {
  // True for `AsyncArrowFunction`, false otherwise.
  attribute boolean isAsync;
  [Lazy] attribute ArrowExpressionContentsWithExpression contents;
};

interface ArrowExpressionContentsWithFunctionBody : Node {
  attribute AssertedParameterScope parameterScope;
  attribute FormalParameters params;
  attribute AssertedVarScope bodyScope;
  attribute FunctionBody body;
};

interface ArrowExpressionContentsWithExpression : Node {
  attribute AssertedParameterScope parameterScope;
  attribute FormalParameters params;
  attribute AssertedVarScope bodyScope;
  attribute Expression body;
};

// `AssignmentExpression :: LeftHandSideExpression = AssignmentExpression`
interface AssignmentExpression : Node {
  // The `LeftHandSideExpression`.
  attribute AssignmentTarget binding;
  // The `AssignmentExpression` following the `=`.
  attribute Expression expression;
};

// `ExponentiationExpression`,
// `MultiplicativeExpression`,
// `AdditiveExpression`,
// `ShiftExpression`,
// `RelationalExpression`,
// `EqualityExpression`,
// `BitwiseANDExpression`,
// `BitwiseXORExpression`,
// `BitwiseORExpression`,
// `LogicalANDExpression`,
// `LogicalORExpression`
interface BinaryExpression : Node {
  attribute BinaryOperator operator;
  // The expression before the operator.
  attribute Expression left;
  // The expression after the operator.
  attribute Expression right;
};

interface CallExpression : Node {
  attribute (Expression or Super) callee;
  attribute Arguments arguments;
};

// `AssignmentExpression :: LeftHandSideExpression AssignmentOperator AssignmentExpression`
interface CompoundAssignmentExpression : Node {
  attribute CompoundAssignmentOperator operator;
  // The `LeftHandSideExpression`.
  attribute SimpleAssignmentTarget binding;
  // The `AssignmentExpression`.
  attribute Expression expression;
};

interface ComputedMemberExpression : Node {
  // The object whose property is being accessed.
  attribute (Expression or Super) _object;
  // The expression resolving to the name of the property to be accessed.
  attribute Expression expression;
};

// `ConditionalExpression :: LogicalORExpression ? AssignmentExpression : AssignmentExpression`
interface ConditionalExpression : Node {
  // The `LogicalORExpression`.
  attribute Expression test;
  // The first `AssignmentExpression`.
  attribute Expression consequent;
  // The second `AssignmentExpression`.
  attribute Expression alternate;
};

// `FunctionExpression`,
// `GeneratorExpression`,
// `AsyncFunctionExpression`,
interface EagerFunctionExpression : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute BindingIdentifier? name;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute FunctionExpressionContents contents;
};
interface LazyFunctionExpression : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute BindingIdentifier? name;
  attribute FrozenArray&lt;Directive&gt; directives;
  [Lazy] attribute FunctionExpressionContents contents;
};

interface FunctionExpressionContents : Node {
  attribute boolean? isFunctionNameCaptured;
  attribute boolean? isThisCaptured;
  attribute AssertedParameterScope parameterScope;
  attribute FormalParameters params;
  attribute AssertedVarScope bodyScope;
  attribute FunctionBody body;
};

// `IdentifierReference`
interface IdentifierExpression : Node {
  attribute Identifier name;
};

interface NewExpression : Node {
  attribute Expression callee;
  attribute Arguments arguments;
};

interface NewTargetExpression : Node { };

interface ObjectExpression : Node {
  attribute FrozenArray&lt;ObjectProperty&gt; properties;
};

interface UnaryExpression : Node {
  attribute UnaryOperator operator;
  attribute Expression operand;
};

interface StaticMemberExpression : Node {
  // The object whose property is being accessed.
  attribute (Expression or Super) _object;
  // The name of the property to be accessed.
  attribute IdentifierName property;
};

// `TemplateLiteral`,
// `MemberExpression :: MemberExpression TemplateLiteral`,
// `CallExpression : CallExpression TemplateLiteral`
interface TemplateExpression : Node {
  // The second `MemberExpression` or `CallExpression`, if present.
  attribute Expression? tag;
  // The contents of the template. This list must be alternating
  // TemplateElements and Expressions, beginning and ending with
  // TemplateElement.
  attribute FrozenArray&lt;(Expression or TemplateElement)&gt; elements;
};

// `PrimaryExpression :: this`
interface ThisExpression : Node { };

// `UpdateExpression :: LeftHandSideExpression ++`,
// `UpdateExpression :: LeftHandSideExpression --`,
// `UpdateExpression :: ++ LeftHandSideExpression`,
// `UpdateExpression :: -- LeftHandSideExpression`
interface UpdateExpression : Node {
  // True for `UpdateExpression :: ++ LeftHandSideExpression` and
  // `UpdateExpression :: -- LeftHandSideExpression`, false otherwise.
  attribute boolean isPrefix;
  attribute UpdateOperator operator;
  attribute SimpleAssignmentTarget operand;
};

// `YieldExpression :: yield`,
// `YieldExpression :: yield AssignmentExpression`
interface YieldExpression : Node {
  // The `AssignmentExpression`, if present.
  attribute Expression? expression;
};

// `YieldExpression :: yield * AssignmentExpression`
interface YieldStarExpression : Node {
  attribute Expression expression;
};

interface AwaitExpression : Node {
  attribute Expression expression;
};


// other statements

interface BreakStatement : Node {
  attribute Label? label;
};

interface ContinueStatement : Node {
  attribute Label? label;
};

interface DebuggerStatement : Node { };

interface DoWhileStatement : Node {
  attribute Expression test;
  attribute Statement body;
};

interface EmptyStatement : Node { };

interface ExpressionStatement : Node {
  attribute Expression expression;
};

interface ForInOfBinding : Node {
  attribute VariableDeclarationKind kind;
  attribute Binding binding;
};

// `for ( LeftHandSideExpression in Expression ) Statement`,
// `for ( var ForBinding in Expression ) Statement`,
// `for ( ForDeclaration in Expression ) Statement`,
// `for ( var BindingIdentifier Initializer in Expression ) Statement`
interface ForInStatement : Node {
  // The expression or declaration before `in`.
  attribute (ForInOfBinding or AssignmentTarget) left;
  // The expression after `in`.
  attribute Expression right;
  attribute Statement body;
};

// `for ( LeftHandSideExpression of Expression ) Statement`,
// `for ( var ForBinding of Expression ) Statement`,
// `for ( ForDeclaration of Expression ) Statement`
interface ForOfStatement : Node {
  // The expression or declaration before `of`.
  attribute (ForInOfBinding or AssignmentTarget) left;
  // The expression after `of`.
  attribute Expression right;
  attribute Statement body;
};

// `for ( Expression ; Expression ; Expression ) Statement`,
// `for ( var VariableDeclarationList ; Expression ; Expression ) Statement`
interface ForStatement : Node {
  // The expression or declaration before the first `;`, if present.
  attribute (VariableDeclaration or Expression)? init;
  // The expression before the second `;`, if present
  attribute Expression? test;
  // The expression after the second `;`, if present
  attribute Expression? update;
  attribute Statement body;
};

// `if ( Expression ) Statement`,
// `if ( Expression ) Statement else Statement`,
interface IfStatement : Node {
  attribute Expression test;
  // The first `Statement`.
  attribute Statement consequent;
  // The second `Statement`, if present.
  attribute Statement? alternate;
};

interface LabelledStatement : Node {
  attribute Label label;
  attribute Statement body;
};

interface ReturnStatement : Node {
  attribute Expression? expression;
};

// A `SwitchStatement` whose `CaseBlock` is
//   `CaseBlock :: { CaseClauses }`.
interface SwitchStatement : Node {
  attribute Expression discriminant;
  attribute FrozenArray&lt;SwitchCase&gt; cases;
};

// A `SwitchStatement` whose `CaseBlock` is
//   `CaseBlock :: { CaseClauses DefaultClause CaseClauses }`.
interface SwitchStatementWithDefault : Node {
  attribute Expression discriminant;
  // The `CaseClauses` before the `DefaultClause`.
  attribute FrozenArray&lt;SwitchCase&gt; preDefaultCases;
  // The `DefaultClause`.
  attribute SwitchDefault defaultCase;
  // The `CaseClauses` after the `DefaultClause`.
  attribute FrozenArray&lt;SwitchCase&gt; postDefaultCases;
};

interface ThrowStatement : Node {
  attribute Expression expression;
};

// `TryStatement :: try Block Catch`
interface TryCatchStatement : Node {
  attribute Block body;
  attribute CatchClause catchClause;
};

// `TryStatement :: try Block Finally`,
// `TryStatement :: try Block Catch Finally`
interface TryFinallyStatement : Node {
  // The `Block`.
  attribute Block body;
  // The `Catch`, if present.
  attribute CatchClause? catchClause;
  // The `Finally`.
  attribute Block finalizer;
};

interface WhileStatement : Node {
  attribute Expression test;
  attribute Statement body;
};

interface WithStatement : Node {
  attribute Expression _object;
  attribute Statement body;
};


// other nodes

interface Block : Node {
  attribute AssertedBlockScope scope;
  attribute FrozenArray&lt;Statement&gt; statements;
};

// `Catch`
interface CatchClause : Node {
  attribute AssertedBoundNamesScope bindingScope;
  attribute Binding binding;
  attribute Block body;
};

// An item in a `DirectivePrologue`
interface Directive : Node {
  attribute string rawValue;
};

interface FormalParameters : Node {
  attribute FrozenArray&lt;Parameter&gt; items;
  attribute Binding? rest;
};

typedef FrozenArray&lt;Statement&gt; FunctionBody;



// `FunctionDeclaration`,
// `GeneratorDeclaration`,
// `AsyncFunctionDeclaration`
interface EagerFunctionDeclaration : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute BindingIdentifier name;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute FunctionOrMethodContents contents;
};

interface LazyFunctionDeclaration : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute BindingIdentifier name;
  attribute FrozenArray&lt;Directive&gt; directives;
  [Lazy] attribute FunctionOrMethodContents content;
};

interface FunctionOrMethodContents : Node {
  attribute boolean isThisCaptured;
  attribute AssertedParameterScope parameterScope;
  attribute FormalParameters params;
  attribute AssertedVarScope bodyScope;
  attribute FunctionBody body;
};


interface Script : Node {
  attribute AssertedScriptGlobalScope scope;
  attribute FrozenArray&lt;Directive&gt; directives;
  attribute FrozenArray&lt;Statement&gt; statements;
};

interface SpreadElement : Node {
  attribute Expression expression;
};

// `super`
interface Super : Node { };

// `CaseClause`
interface SwitchCase : Node {
  attribute Expression test;
  attribute FrozenArray&lt;Statement&gt; consequent;
};

// `DefaultClause`
interface SwitchDefault : Node {
  attribute FrozenArray&lt;Statement&gt; consequent;
};

// `TemplateCharacters`
interface TemplateElement : Node {
  attribute string rawValue;
};

interface VariableDeclaration : Node {
  attribute VariableDeclarationKind kind;
  [NonEmpty] attribute FrozenArray&lt;VariableDeclarator&gt; declarators;
};

interface VariableDeclarator : Node {
  attribute Binding binding;
  attribute Expression? init;
};
  </code></pre>
</emu-clause>

<emu-clause id="binast-transformation">
  <h1>Transformation of AST to Parse Tree</h1>
  <p>The Ecmaify abstract operation transforms binary AST Nodes to ECMAScript Parse Nodes. It performs additional early error checking on top of existing ECMAScript early error semantics.</p>
  <p>A Parse Node may be <dfn>tag</dfn>ged as being transformed by a binary AST Node with an optional asserted scope. The original binary AST Node and the optional asserted scope are retrievable from tagged Parse Nodes.</p>
  <emu-note>Tagging Parse Nodes is used to introduce laziness at function body boundaries.</emu-note>
  <p>The <dfn id="currentassertedscope">current asserted scope</dfn> is used to track asserted scopes during transformation of binary AST Nodes.
  <p>The naming convention of the Ecmaify abstract operations is:</p>
  <ul>
    <li>FooEcmaify always returns a Parse Node of the ECMAScript grammar production |Foo|.</li>
    <li>EcmaifyBar only takes binary AST Node with interface `Bar` and returns Parse Nodes of varying ECMAScript grammar productions.</li>
    <li>Ecmaify is the central dispatcher that dispatches on the interface type of its input.</li>
  </ul>

  <emu-clause id="sec-statementecmaify" aoid="StatementEcmaify">
    <h1>StatementEcmaify ( _stmt_ )</h1>
    <emu-alg>
      1. Assert: _stmt_ is a `Statement`.
      1. Let _n_ be ? Ecmaify(_stmt_).
      1. If _stmt_ is a `Block`, then
          1. Set _n_ to |BlockStatement| : _n_.
      1. Else if _stmt_ is an `IterationStatement`, then
          1. Set _n_ to |BreakableStatement| : _n_.
      1. Else return |Statement| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-statementlistecmaify" aoid="StatementListEcmaify">
    <h1>StatementListEcmaify ( _stmts_ )</h1>
    <emu-alg>
      1. Assert: _stmts_ is a `FrozenArray&lt;Statement>`.
      1. Let _list_ be an empty Parse Node.
      1. If _stmts_ has length 0, then
          1. Let _emptyStmt_ be |StatementListItem| : |EmptyStatement|.
          1. Set _list_ to |StatementList| : _emptyStmt_.
      1. For each _stmt_ in _stmts_, do
          1. If _stmt_ is a `FunctionDeclaration`, then
              1. Set _n_ to |HoistableDeclaration|: ? Ecmaify(_stmt_).
              1. Set _n_ to be |Declaration| : _n_.
          1. Else if _stmt_ an `ExpressionStatement` and _stmt_`.expression` is a `LiteralStringExpression`:
              1. NOTE: String literals expression statements are always parenthsized to avoid being interpreted as directives.
              1. Set _n_ to be ExpressionEcmaify(_stmt_`.expression`).
              1. Set _n_ to be |PrimaryExpression| : <emu-t>(</emu-t> _n_ <emu-t>/</emu-t>.
              1. Set _n_ to be |MemberExpression| : _n_.
              1. Set _n_ to be |NewExpression| : _n_.
              1. Set _n_ to be |LeftHandSideExpression| : _n_.
              1. Set _n_ to be |UpdateExpression| : _n_.
              1. Set _n_ to be |UnaryExpression| : _n_.
              1. Set _n_ to be |ExponentiationExpression| : _n_.
              1. Set _n_ to be |MultiplicativeExpression| : _n_.
              1. Set _n_ to be |AdditiveExpression| : _n_.
              1. Set _n_ to be |ShiftExpression| : _n_.
              1. Set _n_ to be |RelationalExpression| : _n_.
              1. Set _n_ to be |EqualityExpression| : _n_.
              1. Set _n_ to be |BitwiseANDExpression| : _n_.
              1. Set _n_ to be |BitwiseXORExpression| : _n_.
              1. Set _n_ to be |BitwiseORExpression| : _n_.
              1. Set _n_ to be |LogicalANDExpression| : _n_.
              1. Set _n_ to be |LogicalORExpression| : _n_.
              1. Set _n_ to be |AssignmentExpression| : _n_.
              1. Set _n_ to be |Expression| : _n_.
              1. Set _n_ to be |ExpressionStatement| : _n_ <emu-t>;</emu-t>.
          1. Else set _n_ to be ? StatementEcmaify(_stmt_).
          1. Set _n_ to be |StatementListItem| : _n_.
          1. If _list_ is empty, then set _list_ to |StatementList| : _n_.
          1. Else set _list_ to |StatementList| : _list_ _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-variabledeclarationlistecmaify" aoid="VariableDeclarationListEcmaify">
    <h1>VariableDeclarationListEcmaify ( _decls_ )</h1>
    <emu-alg>
      1. Assert: _decls_ is a `FrozenArray&lt;VariableDeclarator>`.
      1. Assert: _decls_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _decl_ in _decls_, do
          1. Let _n_ be an empty Parse Node.
          1. Let _binding_ be ? Ecmaify(_decl_`.binding`).
          1. If _decl_`.init` is *null*, then
              1. If _decl_`.binding` is not a `BindingIdentifier`, throw a *SyntaxError* exception.
              1. Set _n_ to |VariableDeclaration| : _binding_.
          1. Else,
              1. Let _init_ be ? Ecmaify(_decl_`.init`).
              1. Set _n_ to |VariableDeclaration| : _binding_ _init_.
          1. If _list_ is empty, set _list_ to |VariableDeclarationList| : _n_.
          1. Else set _list_ to |VariableDeclarationList| : _list_ _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bindinglistecmaify" aoid="BindingListEcmaify">
    <h1>BindingListEcmaify ( _decls_ )</h1>
    <emu-alg>
      1. Assert: _decls_ is a `FrozenArray&lt;VariableDeclarator>`.
      1. Assert: _decls_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _decl_ in _decls_, do
          1. Let _n_ be an empty Parse Node.
          1. Let _binding_ be ? Ecmaify(_decl_`.binding`).
          1. If _decl_`.init` is *null*, then
              1. If _decl_`.binding` is not a `BindingIdentifier`, throw a *SyntaxError* exception.
              1. Set _n_ to |LexicalBinding| : _binding_.
          1. Else,
              1. Let _init_ be ? Ecmaify(_decl_`.init`).
              1. Set _n_ to |LexicalBinding| : _binding_ _init_.
          1. If _list_ is empty, set _list_ to |BindingList| : _n_.
          1. Else set _list_ to |BindingList| : _list_ _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-elementlistecmaify" aoid="ElementListEcmaify">
    <h1>ElementListEcmaify ( _elems_ )</h1>
    <emu-alg>
      1. Assert: _elems_ is a `FrozenArray&lt;SpreadElement or Expression>`.
      1. Assert: _elems_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. Let _accumulatedElisions_ be an empty Parse Node.
      1. For each _elem_ in _elems_, do
          1. Let _n_ be an empty Parse Node.
          1. If _elem_ is *null*, then
              1. If _accumulatedElisions_ is empty, then set _accumulatedElisions_ to |Elision| : <emu-t>,</emu-t>.
              1. Else set _accumulatedElisions_ to |Elision| : _accumulatedElisions_ <emu-t>,</emu-t>.
          1. Else,
              1. If _elem_ is a SpreadElement, then
                  1. Let _expr_ be ? AssigmentExpressionEcmaify(_elem_`.expression`).
                  1. Set _n_ to |SpreadElement| : <emu-t>...</emu-t> _expr_.
              1. Else set _n_ to ? AssignmentExpressionEcmaify(_elem_).
              1. If _list_ is empty, then
                  1. If _accumulatedElisions_ is empty, then set _list_ to |ElementList| : _n_.
                  1. Else set _list_ to |ElementList| : _accumulatedElisions_ _n_.
              1. Else,
                  1. If _accumulatedElisions_ is empty, then set _list_ to |ElementList| : _list_ <emu-t>,</emu-t> _n_.
                  1. Else set _list_ to |ElementList| : _list_ <emu-t>,</emu-t> _accumulatedElisions_ _n_.
              1. Set _accumulatedElisions_ to an empty Parse Node.
      1. Return _list_ and _accumulatedElisions_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-formalparameterlistecmaify" aoid="FormalParameterListEcmaify">
    <h1>FormalParameterListEcmaify ( _params_ )</h1>
    <emu-alg>
      1. Assert: _params_ is a `FrozenArray&lt;Parameter>`.
      1. Assert: _params_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _param_ in _params_, do
          1. Let _n_ be ? Ecmaify(_param_).
          1. If _list_ is empty, then set _list_ to |FormalParameterList| : _n_.
          1. Else set _list_ to |FormalParameterList| : _list_ <emu-t>,</emu-t> _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-argumentlistecmaify" aoid="ArgumentListEcmaify">
    <h1>ArgumentListEcmaify ( _args_ )</h1>
    <emu-alg>
      1. Assert: _args_ is an `Arguments`.
      1. Assert: _args_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _arg_ in _args_, do
          1. If _arg_ is a `SpreadElement`, then
              1. Let _expr_ be ? AssignmentExpressionEcmaify(_arg_`.expression`).
              1. If _list_ is empty, then set _list_ to |ArgumentList| : <emu-t>...</emu-t> _expr_.
              1. Else set _list_ to |ArgumentList| : _list_ <emu-t>,</emu-t> _expr_.
          1. Else,
              1. Let _expr_ be ? AssignmentExpressionEcmaify(_arg_).
              1. If _list_ is empty, then set _list_ to |ArgumentList| : _expr_.
              1. Else set _list_ to |ArgumentList| : _list_ <emu-t>,</emu-t> _expr_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-propertydefinitionlistecmaify" aoid="PropertyDefinitionListEcmaify">
    <h1>PropertyDefinitionListEcmaify ( _props_ )</h1>
    <emu-alg>
      1. Assert: _props_ is a `FrozenArray&lt;ObjectProperty>` or a `FrozenArray&lt;AssignmentTargetProperty>.
      1. Assert: _props_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _prop_ in _props_, do
          1. If _prop_ is a `MethodDefinition`, then let _n_ be |PropertyDefinition| : ? Ecmaify(_prop_).
          1. Else let _n_ be ? Ecmaify(_prop_).
          1. If _list_ is empty, then set _list_ to |PropertyDefinitionList| : _n_.
          1. Else set _list_ to |PropertyDefinitionList| : _list_ <emu-t>,</emu-t> _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-caseclauseecmaify" aoid="CaseClauseEcmaify">
    <h1>CaseClauseEcmaify ( _case_ )</h1>
    <emu-alg>
      1. Assert: _case_ is a `SwitchCase`.
      1. Let _expr_ be ? ExpressionEcmaify(_case_.test).
      1. Let _clause_ be an empty Parse Node.
      1. If _case_`.consequent` has length 0, then
          1. Set _clause_ to |CaseClause| : <emu-t>case</emu-t> _expr_ <emu-t>:</emu-t>.
      1. Else,
          1. Let _stmts_ be ? StatementListEcmaify(_case_`.consequent`).
          1. Set _clause_ to |CaseClause| : <emu-t>case</emu-t> _expr_ <emu-t>:</emu-t> _stmts_.
      1. Return _clause_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-defaultclauseecmaify" aoid="DefaultClauseEcmaify">
    <h1>DefaultClauseEcmaify ( _case_ )</h1>
    <emu-alg>
      1. Assert: _case_ is a `SwitchDefault`.
      1. Let _clause_ be an empty Parse Node.
      1. If _case_`.consequent` has length 0, then
          1. Set _clause_ to |CaseClause| : <emu-t>default</emu-t> <emu-t>:</emu-t>.
      1. Else,
          1. Let _stmts_ be ? StatementListEcmaify(_case_.consequent).
          1. Set _clause_ to |CaseClause| : <emu-t>default</emu-t> <emu-t>:</emu-t> _stmts_.
      1. Return _clause_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-caseclausesecmaify" aoid="CaseClausesEcmaify">
    <h1>CaseClausesEcmaify ( _cases_ )</h1>
    <emu-alg>
      1. Assert: _cases_ is a `FrozenArray&lt;SwitchCase>`.
      1. Assert: _cases_ does not have length 0.
      1. Let _clauses_ be an empty Parse Node.
      1. For _case_ in _cases_:
          1. Let _clause_ be ? CaseClauseEcmaify(_case_).
          1. If _clauses_ is empty, then set _clauses_ to |CaseClauses| : _clause_.
          1. Else set _clauses_ to |CaseClauses| : _clauses_ _clause_.
      1. Return _clauses_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-argumentsecmaify" aoid="ArgumentsEcmaify">
    <h1>ArgumentsEcmaify ( _args_ )</h1>
    <emu-alg>
      1. Assert: _args_ is an `Arguments`.
      1. If _args_ has length 0, then return |Arguments| : <emu-t>(</emu-t> <emu-t>)</emu-t>.
      1. Else,
          1. Let _list_ be ? ArgumentListEcmaify(_call_`.arguments`).
          1. Return |Arguments| : <emu-t>(</emu-t> _list_ <emu-t>)</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-primaryexpressionecmaify" aoid="PrimaryExpressionEcmaify">
    <h1>PrimaryExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `ThisExpression`, then return ? Ecmaify(_e_).
      1. Else if _pn_ is an `IdentifierExpression`, a `Literal`, an `ArrayExpression`, an `ObjectExpression`, a `FunctionExpression`, a `ClassExpression`, a `LiteralRegExpExpression`, a `TemplateExpression`, an `AssignmentTargetIdentifier`, an `ArrayAssignmentExpression`, or an `ObjectAssignmentExpression`, then return |PrimaryExpression| : ? Ecmaify(_e_).
      1. Else,
          1. Let _parenthesized_ be |ParenthesizedExpression| : <emu-t>(</emu-t> ? ExpressionEcmaify(_e_) <emu-t>)</emu-t>.
          1. Return |PrimaryExpression| : _parenthesized_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-memberexpressionecmaify" aoid="MemberExpressionEcmaify">
    <h1>MemberExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `ComputedMemberExpression`, a `StaticMemberExpression`, a `NewTargetExpression`, a `NewExpression`, a `ComputedMemberAssignmentTarget`, or a `StaticMemberAssignmentTarget`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? PrimaryExpressionEcmaify(_e_).
          1. Return |MemberExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-lefthandsideexpressionecmaify" aoid="LeftHandSideExpressionEcmaify">
    <h1>LeftHandSideExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `NewExpression`, then
          1. Let _n_ be |NewExpression| : ? Ecmaify(_e_).
          1. Return |LeftHandSideExpression| : _n_.
      1. Else if _e_ is a `CallExpression`, then return |LeftHandExpression| : ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be |NewExpression| : ? MemberExpressionEcmaify(_e_).
          1. Return |LeftHandSideExpression|: _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-updateexpressionecmaify" aoid="UpdateExpressionEcmaify">
    <h1>UpdateExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is an `UpdateExpression`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? LeftHandSideExpressionEcmaify(_e_).
          1. Return |UpdateExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-unaryexpressionecmaify" aoid="UnaryExpressionEcmaify">
    <h1>UnaryExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `UnaryExpression`, then return ? Ecmaify(_e_).
      1. Else if _e_ is an `AwaitExpression`, then
          1. Let _n_ be ? Ecmaify(_e_).
          1. Return |UnaryExpression| : _n_.
      1. Else,
          1. Let _n_ be ? UpdateExpressionEcmaify(_e_).
          1. Return |UnaryExpresison| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-exponentiationexpressionecmaify" aoid="ExponentiationExpressionEcmaify">
    <h1>ExponentiationExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"||"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? UnaryExpressionEcmaify(_e_).
          1. Return |ExponentiationExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-multiplicativeexpressionecmaify" aoid="MultiplicativeExpressionEcmaify">
    <h1>MultiplicativeExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"|"`, `"/"`, or `"%"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? ExponentiationExpressionEcmaify(_e_).
          1. Return |MultiplicativeExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-additiveexpressionecmaify" aoid="AdditiveExpressionEcmaify">
    <h1>AdditiveExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"+"` or `"-"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? MultiplicativeExpressionEcmaify(_e_).
          1. Return |AdditiveExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-shiftexpressionecmaify" aoid="ShiftExpressionEcmaify">
    <h1>ShiftExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"<<"`, `">>"`, or `">>>"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? AdditiveExpressionEcmaify(_e_).
          1. Return |ShiftExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-relationalexpressionecmaify" aoid="RelationExpressionEcmaify">
    <h1>RelationalExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"<"`, `">"`, `"<="`, `">="`, `"instanceof"`, or `"in"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? ShiftExpressionEcmaify(_e_).
          1. Return |RelationalExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-equalityexpressionecmaify" aoid="EqualityExpressionEcmaify">
    <h1>EqualityExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"=="`, `"!="`, `"==="`, or `"!=="`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? RelationalExpressionEcmaify(_e_).
          1. Return |EqualityExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bitwiseandexpressionecmaify" aoid="BitwiseANDExpressionEcmaify">
    <h1>BitwiseANDExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"&"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? EqualityExpressionEcmaify(_e_).
          1. Return |BitwiseANDExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bitwisexorexpressionecmaify" aoid="BitwiseXORExpressionEcmaify">
    <h1>BitwiseXORExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"^"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? BitwiseANDExpressionEcmaify(_e_).
          1. Return |BitwiseXORExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bitwiseorexpressionecmaify" aoid="BitwiseORExpressionEcmaify">
    <h1>BitwiseORExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"|"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? BitwiseXORExpressionEcmaify(_e_).
          1. Return |BitwiseORExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-logicalandexpressionecmaify" aoid="LogicalANDExpressionEcmaify">
    <h1>LogicalANDExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"&&"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? BitwiseORExpressionEcmaify(_e_).
          1. Return |LogicalANDExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-logicalorexpressionecmaify" aoid="LogicalORExpressionEcmaify">
    <h1>LogicalORExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"||"`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? LogicalANDExpressionEcmaify(_e_).
          1. Return |LogicalORExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-conditionalexpressionecmaify" aoid="ConditionalExpressionEcmaify">
    <h1>ConditionalExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `ConditionalExpression`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? LogicalORExpressionEcmaify(_e_).
          1. Return |ConditionalExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-assignmentexpressionecmaify" aoid="AssignmentExpressionEcmaify">
    <h1>AssignmentExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is an `AssignmentExpression`, a `CompoundAssignmentExpression`, or an `AssignmentTargetWithInitializer`, then return ? Ecmaify(_e_).
      1. Else if _e_ is a `YieldExpression` or an `ArrowExpression`, then return |AssignmentExpression| : ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? ConditionalExpressionEcmaify(_e_).
          1. Return |AssignmentExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-expressionecmaify" aoid="ExpressionEcmaify">
    <h1>ExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`, an `AssignmentTarget`, or an `AssignmentTargetWithInitializer`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `","`, then return ? Ecmaify(_e_).
      1. Else,
          1. Let _n_ be ? AssignmentExpressionEcmaify(_e_).
          1. Return |Expression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-maybesynthesizethisscope" aoid="MaybeSynthesizeThisScope">
    <h1>MaybeSynthesizeThisScope ( _maybeLazyNode_ )</h1>
    <emu-alg>
      1. If _maybeLazyNode_ is a `LazyFunctionDeclaration`, a `LazyFunctionExpression`, a `LazyMethod`, a `LazyGetter`, a `LazySetter`, or a `LazyArrowExpression`, then return.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Set the current asserted scope to SynthesizeThisScope(_maybeLazyNode_, _enclosingScope_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-maybesynthesizenamedlambdascope" aoid="MaybeSynthesizeNamedLambdaScope">
    <h1>MaybeSynthesizeNamedLambdaScope ( _maybeLazyNode_ )</h1>
    <emu-alg>
      1. If _maybeLazyNode_ is a `LazyFunctionExpression`, then return.
      1. If _maybeLazyNode_`.contents.isFunctionNameCaptured` is *false*, then return.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Set the current asserted scope to SynthesizeNamedLambdaScope(_maybeLazyNode_, _enclosingScope_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-lazyformalparametersecmaify" aoid="LazyFormalParametersEcmaify">
    <h1>LazyFormalParametersEcmaify ( _maybeLazyNode_ )</h1>
    <emu-alg>
      1. NOTE: When a |FormalParameters| : [empty] tagged as being produced by a binary AST `FormalParameters` is evaluated at runtime, Ecmaify is run on the parameters at that time to delazify.
      1. TODO: The `length` property Function instances need delazifying.
      1. If _maybeLazyNode_ is a `LazyFunctionDeclaration`, a `LazyFunctionExpression`, or a `LazyMethod`, then
          1. Let _emptyParams_ be |FormalParameters| : [empty].
          1. Tag _emptyParams_ as being produced by _maybeLazyNode_.
          1. Return _emptyParams_.
      1. Else,
          1. Let _enclosingScope_ be the current asserted scope.
          1. Let _params_ be _maybeLazyNode_`.contents.params`.
          1. Let _paramScope_ be _maybeLazyNode_`.contents.parameterScope`.
          1. Assert: _params_ is a `FormalParameters`.
          1. Set the current asserted scope to _paramScope_.
          1. Perform AddAssertedScopeTreeNode(_paramScope_, _enclosingScope_).
          1. Let _delazifiedParams_ be ? EcmaifyFormalParameters(_params_).
          1. Perform ? CheckAssertedScope(_paramScope_, _delazifiedParams_).
          1. Return _delazifiedParams_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-lazycoverarrowparameterlistecmaify" aoid="LazyCoverArrowParameterListEcmaify">
    <h1>LazyCoverArrowParameterListEcmaify ( _maybeLazyNode_ )</h1>
    <emu-alg>
      1. NOTE: When a |CoverParenthesizedExpressionAndArrowParameterList| : <emu-t>(</emu-t> <emu-t>)</emu-t> tagged as being produced by a binary AST `FormalParameters` is evaluated at runtime, Ecmaify is run on the parameters at that time to delazify.
      1. TODO: The `length` property Function instances need delazifying.
      1. If _maybeLazyNode_ is a `LazyArrowExpression`, then
          1. Let _emptyArrowParams0_ be a |CoverParenthesizedExpressionAndArrowParameterList| : <emu-t>(</emu-t> <emu-t>)</emu-t>.
          1. Let _emptyArrowParams_ be |ArrowParameters| : _emptyArrowParams0_.
          1. Tag _emptyArrowParams_ as being produced by _maybeLazyNode_.
          1. Return _emptyArrowParams_.
      1. Else,
          1. Let _params_ be _maybeLazyNode_`.content.params`.
          1. Let _paramScope_ be _maybeLazyNode_`.content.parameterScope`.
          1. Assert: _params_ is a `FormalParameters`.
          1. Let _enclosingScope_ be the current asserted scope.
          1. Set the current asserted scope to _paramScope_.
          1. Perform AddAssertedScopeTreeNode(_paramScope_, _enclosingScope_).
          1. Let _delazifiedParams_ be ? EcmaifyCoverArrowParameterList(_params_).
          1. Perform ? CheckAssertedScope(_paramScope_, _delazifiedParams_).
          1. Perform ? CheckThisCapture(_paramScope_, _delazifiedParams_).
          1. Return _delazifiedParams_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-lazypropertysetparameterlistecmaify" aoid="LazyPropertySetParameterListEcmaify">
    <h1>LazyPropertySetParameterListEcmaify ( _maybeLazyNode_ )</h1>
    <emu-alg>
      1. NOTE: When a |PropertySetParameterList| tagged as being produced by a binary AST `Parameter` is evaluated at runtime, Ecmaify is run on the parameter at that time to delazify.
      1. TODO: The `length` property Function instances need delazifying.
      1. TODO: |FormalParameter| needs an empty variant for tagging.
      1. If _maybeLazyNode_ is a `LazySetter`, then
          1. Let _placeholder_ be |Identifier| : <emu-t>_</emu-t>.
          1. Let _emptyPropSetParam0_ be |FormalParameter| : _placeholder_.
          1. Let _emptyPropSetParam_ be |PropertySetParameterList| : _emptyPropSetParam0_.
          1. Let _currentScope_ be the current asserted scope.
          1. Tag _emptyPropSetParam_ as being produced by _maybeLazyNode_.
          1. Return _emptyPropSetParam_.
      1. Else,
          1. Let _param_ be _maybeLazyNode_`.contents.param`.
          1. Let _paramScope_ be _maybeLazyNode_`.contents.parameterScope`.
          1. Assert: _param_ is a `Parameter`.
          1. Let _enclosingScope_ be the current asserted scope.
          1. Set the current asserted scope to _paramScope_.
          1. Perform AddAssertedScopeTreeNode(_paramScope_, _enclosingScope_).
          1. Let _delazifiedParams_ be ? EcmaifyPropertySetParameterList(_param_).
          1. Perform ? CheckAssertedScope(_paramScope_, _delazifiedParams_).
          1. Return _delazifiedParams_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-lazyfunctionbodyecmaify" aoid="LazyFunctionBodyEcmaify">
    <h1>LazyFunctionBodyEcmaify ( _maybeLazyNode_ )</h1>
    <emu-alg>
      1. NOTE: When a |FunctionBody| tagged as being produced by a binary AST is evaluated at runtime, Ecmaify is run on the function at that time to delazify.
      1. If _maybeLazyNode_ is a `LazyFunctionDeclaration`, a `LazyFunctionExpression`, a `LazyMethod`, a `LazyGetter`, a `LazySetter`, or a `LazyArrowExpression`, then
          1. Let _emptyStmt_ be |StatementListItem| : |EmptyStatement|.
          1. Let _stmts_ be |StatementList| : _emptyStmt_.
          1. Let _funcStmts_ be |FunctionStatementList| : _stmts_.
          1. Let _body_ be |FunctionBody| : _funcStmts_.
          1. Let _currentScope_ be the current asserted scope.
          1. Tag _body_ as being produced by _maybeLazyNode_ in scope _currentScope_.
          1. Return _body_.
      1. Else,
          1. Let _enclosingScope_ be the current asserted scope.
          1. Let _contents_ be _maybeLazyNode_`.contents`.
          1. Let _bodyScope_ be _contents_`.bodyScope`.
          1. Set the current asserted scope to _bodyScope_.
          1. Perform AddAssertedScopeTreeNode(_bodyScope_, _enclosingScope_).
          1. Let _delazifiedBody_ be ? EcmaifyFunctionBody(_funcNode_).
          1. Perform ? CheckAssertedScope(_bodyScope_, _delazifiedBody_).
          1. If _contents_ is an `ArrowExpressionContents`, then perform ? CheckThisCapture(_bodyScope_, _delazifiedBody_).
          1. Return |FunctionBody| : _delazifiedBody_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-identifierecmaify" aoid="IdentifierEcmaify">
    <h1>IdentifierEcmaify ( _ident_ )</h1>
    <emu-alg>
      1. Assert: _ident_ is an `Identifier` or an `IdentifierName`.
      1. NOTE: The full tree of identifiers is elided here and left as an exercise to the reader.
      1. If _ident_ is the empty string, throw a *SyntaxError* exception.
      1. Return |Identifier| : _ident_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-labelidentifierecmaify" aoid="LabelIdentifierEcmaify">
    <h1>LabelIdentifierEcmaify ( _l_ )</h1>
    <emu-alg>
      1. Assert: _l_ is a `Label`.
      1. If _l_ is `"yield"`, then return |LabelIdentifier| : <emu-t>yield</emu-t>.
      1. Else if _l_ is `"await"`, then return |LabelIdentifier| : <emu-t>await</emu-t>.
      1. Else return |LabelIdentifier| : ? IdentifierEcmaify(_l_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-initializerecmaify" aoid="InitializerEcmaify">
    <h1>InitializerEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. Return |Initializer| : <emu-t>=</emu-t> ? AssignmentExpressionEcmaify(_e_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bindingpropertylistecmaify" aoid="BindingPropertyListEcmaify">
    <h1>BindingPropertyListEcmaify ( _props_ )</h1>
    <emu-alg>
      1. Assert: _props_ is a `FrozenArray&lt;BindingProperty>`.
      1. Assert: _props_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _prop_ in _props_, do
          1. Let _bindingProp_ be ? Ecmaify(_binding_).
          1. If _list_ is empty, set _list_ to |BindingPropertyList| : _bindingProp_.
          1. Else set _list_ to |BindingPropertyList| : _list_ <emu-t>,</emu-t> _bindingProp_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bindingelementlistecmaify" aoid="BindingElementListEcmaify">
    <h1>BindingElementListEcmaify ( _elems_ )</h1>
    <emu-alg>
      1. Assert: _elems_ is a `FrozenArray&lt;(Binding or BindingWithInitializer)>`.
      1. Assert: _elems_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. Let _accumulatedElisions_ be an empty Parse Node.
      1. For each _elem_ in _elems_, do
          1. Let _bindingElem_ be an empty Parse Node.
          1. If _elem_ is *null*, then
              1. If _accumulatedElisions_ is empty, then set _accumulatedElisions_ to |Elision| : <emu-t>,</emu-t>.
              1. Else set _accumulatedElisions_ to |Elision| : _accumulatedElisions_ <emu-t>,</emu-t>.
          1. Else,
              1. Let _bindingElem_ be |BindingElisionElement| : _accumulatedElisions_ ? BindingElementEcmaify(_elem_).
              1. If _list_ is empty, then set _list_ to |BindingElementList| : _bindingElem_.
              1. Else set _list_ to |BindingElementList| : _list_ <emu-t>,</emu-t> _bindingElem_.
              1. Set _accumulatedElisions_ to an empty Parse Node.
      1. Return _list_ and _accumulatedElisions_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bindingelementecmaify" aoid="BindingElementEcmaify">
    <h1>BindingElementEcmaify ( _binding_ )</h1>
    <emu-alg>
      1. Assert: _binding_ is a `Binding or BindingWithInitializer`.
      1. Let _elem0_ be ? Ecmaify(_binding_).
      1. If _binding_ is a `BindingWithInitializer`, then return _elem0_.
      1. Else,
          1. If _binding_ is a `BindingIdentifier`, then
              1. Let _singleNameBinding_ be |SingleNameBinding| : _elem0_.
              1. Return |BindingElement| : _singleNameBinding_.
          1. Else,
              1. Let _bindingPattern_ be |BindingPattern| : _elem0_.
              1. Return |BindingElement| : _bindingPattern_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bindingrestelementecmaify" aoid="BindingRestElementEcmaify">
    <h1>BindingRestElementEcmaify ( _rest_ )</h1>
    <emu-alg>
      1. Assert: _rest_ is a `Binding`.
      1. Let _restBinding_ be ? Ecmaify(_rest_).
      1. If _rest_ is a `BindingPattern`, then let _restElem0_ be |BindingPattern| : _restBinding_.
      1. Else let _restElem0_ be _restBinding_.
      1. Return |BindingRestElement| : <emu-t>...</emu-t> _restElem0_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyscript" aoid="EcmaifyScript">
    <h1>EcmaifyScript ( _s_ )</h1>
    <emu-alg>
      1. NOTE: This may be called when a binary AST corresponding to a script is evaluated via BinaryASTScriptEvaluationJob.
      1. Assert: _s_ is a `Script`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Set the current asserted scope to _s_`.scope`.
      1. Perform AddAssertedScopeTreeNode(_s_`.scope`, _enclosingScope_).
      1. Let _dirsStmts_ be _s_`.directives` prepended to _s_`.statements`.
      1. Let _script_ be an empty Parse Node.
      1. If _s_`.directives` has length 0 and _s_`.statements` has length 0, then
          1. Set _script_ to |Script| :.
      1. Else,
          1. Let _dirStmts_ be _s_`.directives` concatenated with _s_`.statements`.
          1. Let _stmts_ be ? StatementListEcmaify(_dirStmts_).
          1. Set _script_ to |Script| : _stmts_.
      1. Perform ? CheckAssertedScope(_s_`.scope`, _script_).
      1. Set the current asserted scope to _enclosingScope_.
      1. Return _script_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifymodule" aoid="EcmaifyModule">
    <h1>EcmaifyModule ( _m_ )</h1>
    <emu-alg>
      1. NOTE: This may be called when a binary AST corresponding to a module is evaluated via BinaryASTTopLevelModuleEvaluationJob.
      1. Assert: _m_ is a `Module`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyformalparameters" aoid="EcmaifyFormalParameters">
    <h1>EcmaifyFormalParameters ( _params_ )</h1>
    <emu-alg>
      1. NOTE: This may be called when a |FormalParameters| tagged as being produced by a binary AST `FormalParameters` is evaluated.
      1. Assert: _params_ is a `FormalParameters`.
      1. If _params_`.items` has length 0, then
          1. If _params_`.rest` is null, then return |FormalParameters| :.
          1. Else,
              1. Let _rest_ be |FunctionRestParameter| : ? BindingRestElementEcmaify(_params_`.rest`).
              1. Return |FormalParameters| : _rest_.
      1. Else,
          1. Let _list_ be ? FormalParameterListEcmaify(_params_`.items`).
          1. If _params_`.rest` is null, then return |FormalParameters| : _list_.
          1. Else,
              1. Let _rest_ be |FunctionRestParameter| : ? BindingRestElementEcmaify(_params_`.rest`).
              1. Return |FormalParameters| : _list_ <emu-t>,</emu-t> _rest_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycoverarrowparameterlist" aoid="EcmaifyCoverArrowParameterList">
    <h1>EcmaifyCoverArrowParameterList ( _params_ )</h1>
    <emu-alg>
      1. NOTE: This may be called when an |ArrowParameters| tagged as being produced by a binary AST `FormalParameters` is evaluated.
      1. Assert: _params_ is a `FormalParameters`.
      1. Let _params0_ be |UniqueFormalParameters| : ? EcmaifyFormalParameters(_params_).
      1. Return _params_ |ArrowFormalParameters| : <emu-t>(</emu-t> _params0_ <emu-t>)</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifypropertysetparameterlist" aoid="EcmaifyPropertySetParameterList">
    <h1>EcmaifyPropertySetParameterList ( _param_ )</h1>
    <emu-alg>
      1. Assert: _param_ is a `Parameter`.
      1. Let _param0_ ? Ecmaify(_param_).
      1. Return |PropertySetParameterList| : _param0_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyfunctionbody" aoid="EcmaifyFunctionBody">
    <h1>EcmaifyFunctionBody ( _f_ )</h1>
    <emu-alg>
      1. NOTE: This may be called when an |EmptyStatement| tagged as being produced by a binary AST `FunctionBody` is evaluated.
      1. Assert: _f_ is a `FunctionDeclaration`, a `FunctionExpression`, a `Method`, a `Getter`, a `Setter`, or a `ArrowExpression`.
      1. Let _stmts_ be an empty Parse Node.
      1. If _f_`.contents.body` is a `FunctionBody`, then
          1. NOTE: Directives must be non-null, but possibly empty, if the function body is a StatementList.
          1. If _f_ is an `ArrowExpression` and _f_`.directives` is *null*, then throw a *SyntaxError*.
          1. Let _dirStmts_ be _f_`.directives` concatenated with _f_`.contents.body`.
          1. Set _stmts_ to ? StatementListEcmaify(_dirStmts_).
      1. Else,
          1. Assert: _f_`.contents.body` is an `Expression`.
          1. NOTE: Directives must be null if the function is an arrow and the body is an expression.
          1. If _f_`.directives` is not *null*, then throw a *SyntaxError*.
          1. Let _stmt_ be |ReturnStatement| : <emu-t>return</emu-t> ? ExpressionEcmaify(_f_`.contents.body`) <emu-t>;</emu-t>.
          1. Let _stmtItem_ be |StatementListItem| : _stmt_.
          1. Let _stmts_ be |StatementList| : _stmtItem_.
      1. Let _funcStmts_ be |FunctionStatementList| : stmts_.
      1. Return |FunctionBody| : _funcStmts_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyblock" aoid="EcmaifyBlock">
    <h1>EcmaifyBlock ( _b_ )</h1>
    <emu-alg>
      1. Assert: _b_ is a `Block`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Set the current asserted scope to _b_`.scope`.
      1. Perform AddAssertedScopeTreeNode(_b_`.scope`, _enclosingScope_).
      1. Let _stmts_ be ? StatementListEcmaify(_b_`.statements`).
      1. Let _block_ be |Block| : <emu-t>{</emu-t> _stmts_ <emu-t>}</emu-t>.
      1. Perform ? CheckAssertedScope(_b_`.scope`, _block_).
      1. Set the current asserted scope to _enclosingScope_.
      1. Return _block_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifydirective" aoid="EcmaifyDirective">
    <h1>EcmaifyDirective ( _directive_ )</h1>
    <emu-alg>
      1. Assert: _directive_ is a `Directive`.
      1. Let _v_ be the value of _directive_`.rawValue` escaped for double quotes.
      1. Let _l_ be |StringLiteral| : <emu-t>"</emu-t> _v_ <emu-t>"</emu-t>.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybreakstatement" aoid="EcmaifyBreakStatement">
    <h1>EcmaifyBreakStatement ( _brk_ )</h1>
    <emu-alg>
      1. Assert: _brk_ is a `BreakStatement`.
      1. If _brk_`.label` is *null*, then return |BreakStatement| : <emu-t>break</emu-t> <emu-t>;</emu-t>.
      1. Else return |BreakStatement| : <emu-t>break</emu-t> ? LabelIdentifierEcmaify(_brk_`.label`) <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycontinuestatement" aoid="EcmaifyContinueStatement">
    <h1>EcmaifyContinueStatement ( _cont_ )</h1>
    <emu-alg>
      1. Assert: _cont_ is a `ContinueStatement`.
      1. If _cont_`.label` is *null*, then
          1. Return |ContinueStatement| : <emu-t>continue</emu-t> <emu-t>;</emu-t>.
      1. Else return |ContinueStatement| : <emu-t>continue</emu-t> ? LabelIdentifierEcmaify(_cont_`.label`) <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyclassdeclaration" aoid="EcmaifyClassDeclaration">
    <h1>EcmaifyClassDeclaration (_cls_ )</h1>
    <emu-alg>
      1. Assert: _cls_ is a `ClassDeclaration`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifydebuggerstatement" aoid="EcmaifyDebuggerStatement">
    <h1>EcmaifyDebuggerStatement ( _dbg_ )</h1>
    <emu-alg>
      1. Assert: _dbg_ is a `DebuggerStatement`.
      1. Return |DebuggerStatement| : <emu-t>debugger</emu-t> <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyemptystatement" aoid="EcmaifyEmptyStatement">
    <h1>EcmaifyEmptyStatement ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `EmptyStatement`.
      1. Return |EmptyStatement| : <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyexpressionstatement" aoid="EcmaifyExpressionStatement">
    <h1>EcmaifyExpressionStatement ( _expr_ )</h1>
    <emu-alg>
      1. Assert: _expr_ is an `ExpressionStatement`.
      1. Return |ExpressionStatement| : ? ExpressionEcmaify(_expr_`.expression`) <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyfunctiondeclaration" aoid="EcmaifyFunctionDeclaration">
    <h1>EcmaifyFunctionDeclaration ( _func_ )</h1>
    <emu-alg>
      1. Assert: _func_ is an `EagerFunctionDeclaration` or a `LazyFunctionDeclaration`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Let _funcName_ be ? Ecmaify(_func_`.name`).
      1. Perform MaybeSynthesizeThisScope(_func_).
      1. Let _params_ be ? LazyFormalParametersEcmaify(_func_).
      1. If _func_`.isAsync` is *true*, then
          1. Let _body_ be |AsyncFunctionBody| : ? LazyFunctionBodyEcmaify(_func_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Return |AsyncFunctionDeclaration| : <emu-t>async</emu-t> <emu-t>function</emu-t> _funcName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else if _func_`.isGenerator` is *true*, then
          1. Let _body_ be |GeneratorBody| : ? LazyFunctionBodyEcmaify(_func_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Return |GeneratorDeclaration| : <emu-t>function</emu-t> <emu-t>`*`</emu-t> _funcName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else,
          1. Let _body_ be ? LazyFunctionBodyEcmaify(_func_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Return |FunctionDeclaration| : <emu-t>function</emu-t> _funcName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyifstatement" aoid="EcmaifyIfStatement">
    <h1>EcmaifyIfStatement ( _if_ )</h1>
    <emu-alg>
      1. Assert: _if_ is an `IfStatement`.
      1. Let _test_ be ? Ecmaify(_if_`.test`).
      1. Let _then_ be ? Ecmaify(_if_`.consequent`).
      1. If _if_`.alternate` is *null*, then
          1. Return |IfStatement| : <emu-t>if</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> _then_.
      1. Else return |IfStatement| : <emu-t>if</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> _then_ <emu-t>else</emu-t> ? StatementEcmaify(_if_`.alternate`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifydowhilestatement" aoid="EcmaifyDoWhileStatement">
    <h1>EcmaifyDoWhileStatement ( _doWhile_  )</h1>
    <emu-alg>
      1. Assert: _doWhile_ is a `DoWhileStatement`.
      1. Let _test_ be ? ExpressionEcmaify(_doWhile_`.test`).
      1. Let _body_ be ? StatementEcmaify(_doWhile_`.body`).
      1. Return |IterationStatement| : <emu-t>do</emu-t> _body_ <emu-t>while</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforinstatement" aoid="EcmaifyForInStatement">
    <h1>EcmaifyForInStatement ( _forIn_ )</h1>
    <emu-alg>
      1. Assert: _forIn_ is a `ForInStatement`.
      1. Let _left_ be an empty Parse Node.
      1. Let _right_ be ? AssignmentExpressionEcmaify(_forIn_`.right`).
      1. Let _body_ be ? StatementEcmaify(_forIn_`.body`).
      1. If _forIn_`.left` is a `ForInOfBinding`, then
          1. If _forIn_`.left.kind` is `"var"`, then
              1. Let _varBinding_ be |ForBinding| : ? Ecmaify(_forIn_`.left.binding`).
              1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> <emu-t>var</emu-t> _varBinding_ <emu-t>in</emu-t> _right_ <emu-t>)</emu-t> _body_.
          1. Else set _left_ to ? Ecmaify(_forIn_`.left`).
      1. Else set _left_ to ? LeftHandSideExpressionEcmaify(_forIn_`.left`).
      1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> _left_ <emu-t>in</emu-t> _right_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforofstatement" aoid="EcmaifyForOfStatement">
    <h1>EcmaifyForOfStatement ( _forOf_ )</h1>
    <emu-alg>
      1. Assert: _forOf_ is a `ForOfStatement`.
      1. Let _left_ be an empty Parse Node.
      1. Let _right_ be ? AssignmentExpressionEcmaify(_forOf_`.right`).
      1. Let _body_ be ? StatementEcmaify(_forOf_`.body`).
      1. If _forOf_`.left` is a `ForInOfBinding`, then
          1. If _forOf_`.left.kind` is `"var"`, then
              1. Let _varBinding_ be |ForBinding| : ? Ecmaify(_forOf_`.left.binding`).
              1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> <emu-t>var</emu-t> _varBinding_ <emu-t>of</emu-t> _right_ <emu-t>)</emu-t> _body_.
          1. Else set _left_ to ? Ecmaify(_forOf_`.left`).
      1. Else set _left_ to ? LeftHandSideExpressionEcmaify(_forOf_`.left`).
      1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> _left_ <emu-t>of</emu-t> _right_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforstatement" aoid="EcmaifyForStatement">
    <h1>EcmaifyForStatement ( _for_ )</h1>
    <emu-alg>
      1. Assert: _for_ is a `ForStatement`.
      1. Let _init_, _test_, and _update_ be empty Parse Nodes.
      1. If _for_`.test` is not null, then set _test_ to ? ExpressionEcmaify(_for_`.test`).
      1. If _for_`.update` is not null, then set _update_ to ? ExperssionEcmaify(_for_`.test`).
      1. Let _body_ be ? StatementEcmaify(_for_`.body`).
      1. If _for_`.init` is not *null*, then
          1. If _for_`.init` is a `VariableDeclaration`, then
              1. If _for_`.init.kind` is `"var"`, then
                  1. Let _varDecls_ be ? VariableDeclarationListEcmaify(_for_`.init.declarators`).
                  1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> <emu-t>var</emu-t> _varDecls_ <emu-t>;</emu-t> _test_ <emu-t>;</emu-t> _update_ <emu-t>)</emu-t> _body_.
              1. Else set _init_ to |LexicalDeclaration| : ? Ecmaify(_for_`.init.kind`) ? BindingListEcmaify(_for_`.init.declarators`).
          1. Else set _init_ to ? LeftHandSideExpressionEcmaify(_for_`.init`).
      1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> _init_ <emu-t>;</emu-t> _test_ <emu-t>;</emu-t> _update_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifywhilestatement" aoid="EcmaifyWhileStatement">
    <h1>EcmaifyWhileStatement ( _while_ )</h1>
    <emu-alg>
      1. Assert: _while_ is a `WhileStatement`.
      1. Let _test_ be ? ExpressionEcmaify(_while_`.test`).
      1. Let _body_ be ? StatementEcmaify(_while_`.body`).
      1. Return |IterationStatement| : <emu-t>while</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifylabelledstatement" aoid="EcmaifyLabelledStatement">
    <h1>EcmaifyLabelledStatement ( _labelled_ )</h1>
    <emu-alg>
      1. Assert _labelled_ is a `LabelledStatement`.
      1. Let _body_ be an empty Parse Node.
      1. If _labelled_`.body` is a `FunctionDeclaration`, then
          1. If _labelled_`.body.isAsync` is true or _labelled_`.body.isGenerator` is *true*, then throw a *SyntaxError* exception.
          1. Set _body_ to ? Ecmaify(_labelled_`.body`).
      1. Else set _body_ to ? StatementEcmaify(_labelled_`.body`).
      1. Let _item_ be |LabelledItem| : _body_.
      1. Return |LabelledStatement| : ? LabelIdentifierEcmaify(_labelled_`.label`) <emu-t>:</emu-t> _item_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyreturnstatement" aoid="EcmaifyReturnStatement">
    <h1>EcmaifyReturnStatement ( _ret_ )</h1>
    <emu-alg>
      1. Assert: _ret_ is a `ReturnStatement`.
      1. If _ret_`.expression` is *null*, then
          1. Return |ReturnStatement| : <emu-t>return</emu-t> <emu-t>;</emu-t>.
      1. Else return |ReturnStatement| : <emu-t>return</emu-t> ? ExpressionEcmaify(_ret_`.expression`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyswitchstatement" aoid="EcmaifySwitchStatement">
    <h1>EcmaifySwitchStatement ( _switch_ )</h1>
    <emu-alg>
      1. Assert: _switch_ is a `SwitchStatement`.
      1. Let _expr_ be ? ExpressionEcmaify(_switch_`.discriminant`).
      1. Let _block_ be an empty Parse Node.
      1. If _switch_`.cases` has length 0, then set _block_ to |CaseBlock| : <emu-t>{</emu-t> <emu-t>}</emu-t>.
      1. Else,
          1. Let _clauses_ be ? CaseClausesEcmaify(_switch_`.cases`).
          1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _clauses_ <emu-t>}</emu-t>.
      1. Return |SwitchStatement| : <emu-t>switch</emu-t> <emu-t>(</emu-t> _expr_ <emu-t>)</emu-t> _block_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyswitchstatementwithdefault" aoid="EcmaifySwitchStatementWithDefault">
    <h1>EcmaifySwitchStatementWithDefault ( _switch_ )</h1>
    <emu-alg>
      1. Assert: _switch_ is a `SwitchStatementWithDefault`.
      1. Let _expr_ be ? ExpressionEcmaify(_switch_`.discriminant`).
      1. Let _defaultClause_ be ? DefaultClauseEcmaify(_switch_`.defaultCase`).
      1. Let _block_ be an empty Parse Node.
      1. If _switch_`.preDefaultCases` has length 0, then
          1. If _switch_`.postDefaultCases` has length 0, then
              1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _defaultClause_ <emu-t>}</emu-t>.
          1. Else,
              1. Let _postDefaultClauses_ be ? CaseClausesEcmaify(_switch_`.postDefaultCases`).
              1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _defaultClause_ _postDefaultClauses_ <emu-t>}</emu-t>.
      1. Else if _switch_`.postDefaultCases` has length 0, then
          1. Let _preDefaultClauses_ be ? CaseClausesEcmaify(_switch_`.preDefaultCases`).
          1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _preDefaultClauses_ _defaultClause_ <emu-t>}</emu-t>
      1. Else,
          1. Let _preDefaultClauses_ be ? CaseClausesEcmaify(_switch_`.preDefaultCases`).
          1. Let _postDefaultClauses_ be ? CaseClausesEcmaify(_switch_`.postDefaultCases`).
          1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _preDefaultClauses_ _defaultClause_ _postDefaultClauses_ <emu-t>}</emu-t>.
      1. Return |SwitchStatement| : <emu-t>switch</emu-t> <emu-t>(</emu-t> _expr_ <emu-t>)</emu-t> _block_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifythrowstatement" aoid="EcmaifyThrowStatement">
    <h1>EcmaifyThrowStatement ( _throw_ )</h1>
    <emu-alg>
      1. Assert: _throw_ is a `ThrowStatement`.
      1. Return |ThrowStatement| : <emu-t>throw</emu-t> ? ExpressionEcmaify(_throw_`.expression`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifytrycatchstatement" aoid="EcmaifyTryCatchStatement">
    <h1>EcmaifyTryCatchStatement ( _tryCatch_ )</h1>
    <emu-alg>
      1. Assert: _tryCatch_ is a `TryCatchStatement`.
      1. Let _block_ be ? Ecmaify(_tryCatch_`.body`).
      1. Let _catch_ be ? Ecmaify(_tryCatch_`.catchClause`).
      1. Return |TryStatement| : <emu-t>try</emu-t> _block_ _catch_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifytryfinallyStatement" aoid="EcmaifyTryFinallyStatement">
    <h1>EcmaifyTryFinallyStatement ( _tryFinally_ )</h1>
    <emu-alg>
      1. Assert: _tryFinally_ is a `TryFinallyStatement`.
      1. Let _block_ be ? Ecmaify(_tryFinally_`.body`).
      1. Let _finally_ be |Finally| : <emu-t>finally</emu-t> ? Ecmaify(_tryFinally_`.finalizer`).
      1. If _tryFinally_`.catch` is *null*, then
          1. Return |TryStatement| : <emu-t>try</emu-t> _block_ _finally_.
      1. Else,
          1. Let _catch_ be ? Ecmaify(_tryFinally_`.catchClause`).
          1. Return |TryStatement| : <emu-t>try</emu-t> _block_ _catch_ _finally_.
  </emu-clause>

  <emu-clause id="sec-ecmaifyvariabledeclaration" aoid="EcmaifyVariableDeclaration">
    <h1>EcmaifyVariableDeclaration ( _decl_ )</h1>
    <emu-alg>
      1. Assert: _decl_ is a `VariableDeclaration`.
      1. If _decl_`.kind` is `"var"`, then
          1. Let _varDecls_ be ? VariableDeclarationListEcmaify(_decl_`.declarators`).
          1. Return |VariableStatement| : <emu-t>var</emu-t> _varDecls_ <emu-t>;</emu-t>.
      1. Else,
          1. Let _letOrConst_ be ? Ecmaify(_decl_`.kind`).
          1. Let _lexDecls_ be ? BindingListEcmaify(_decl_`.declarators`).
          1. Return |LexicalDeclaration| : _letOrConst_ _lexDecls_ <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifywithstatement" aoid="EcmaifyWithStatement">
    <h1>EcmaifyWithStatement ( _with_ )</h1>
    <emu-alg>
      1. Assert: _with_ is a `WithStatement`.
      1. Let _expr_ be ? ExpressionEcmaify(_with_`._object`).
      1. Let _body_ be ? StatementEcmaify(_with_`.body`).
      1. Return |WithStatement| : <emu-t>with</emu-t> <emu-t>(</emu-t> _expr_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralbooleanexpression" aoid="EcmaifyLiteralBooleanExpression">
    <h1>EcmaifyLiteralBooleanExpression ( _litBool_ )</h1>
    <emu-alg>
      1. Assert: _litBool_ is a `LiteralBooleanExpression`.
      1. Let _l_ be an empty Parse Node.
      1. If _litBool_`.value` is *true*, then set _l_ to |BooleanLiteral| : <emu-t>true</emu-t>.
      1. Else set _l_ to |BooleanLiteral| : <emu-t>false</emu-t>.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralinfinityexpression" aoid="EcmaifyLiteralInfinityExpression">
    <h1>EcmaifyLiteralInfinityExpression ( _litInfty_ )</h1>
    <emu-alg>
      1. NOTE: The full tree of numeric literals is elided here and left as an exercise to the reader.
      1. NOTE: This node is not for the `Infinity` identifier, but for literal decimals whose mathematical values exceed the bounds of IEEE doubles.
      1. Assert: _litInfty_ is a `LiteralInfinityExpresion`.
      1. Let _l0_ be |DecimalLiteral| : <emu-t>2e308</emu-t>.
      1. Let _l1_ be |NumericLiteral| : _l0_.
      1. Return |Literal| : _l1_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralnullexpression" aoid="EcmaifyLiteralNullExpression">
    <h1>EcmaifyLiteralNullExpression ( _litNull_ )</h1>
    <emu-alg>
      1. Assert: _litNull_ is a `LiteralNullExpression`.
      1. Let _l_ be |NullLiteral| : <emu-t>null</emu-t>.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralnumericexpression" aoid="EcmaifyLiteralNumericExpression">
    <h1>EcmaifyLiteralNumericExpression ( _litNumeric_ )</h1>
    <emu-alg>
      1. NOTE: The full tree of numeric literals is elided here and left as an exercise to the reader.
      1. NOTE: The value in _litNumeric_ is positive, non-NaN, and finite.
      1. Assert: _litNumeric_ is a `LiteralNumericExpression`.
      1. Let _l_ be |DecimalLiteral| : _litNumeric_`.value`.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralregexpexpression" aoid="EcmaifyLiteralRegExpExpression">
    <h1>EcmaifyLiteralRegExpExpression ( _litRegexp_ )</h1>
    <emu-alg>
      1. NOTE: The full tree of regular expression literals is elided here and left as an exercise to the reader.
      1. Assert: _litRegExp_ is a `LiteralRegExpExpression`.
      1. Let _body_ be |RegularExpressionBody| : _litRegexp_`.pattern`.
      1. Let _flags_ be |RegularExpressionFlags| : _litRegexp_`.flags`.
      1. Return |RegularExpressionLiteral| : <emu-t>/</emu-t> _body_ <emu-t>/</emu-t> _flags_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralstringexpression" aoid="EcmaifyLiteralStringExpression">
    <h1>EcmaifyLiteralStringExpression ( _litStr_ )</h1>
    <emu-alg>
      1. Assert: _litStr_ is a `LiteralStringExpression`.
      1. Let _v_ be the value of _litStr_`.value` escaped for double quotes.
      1. Let _l_ be |StringLiteral| : <emu-t>"</emu-t> _v_ <emu-t>"</emu-t>.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyarrayexpression" aoid="EcmaifyArrayExpression">
    <h1>EcmaifyArrayExpression ( _litArray_ )</h1>
    <emu-alg>
      1. Assert: _litArray_ is an `ArrayExpression` or an `ArrayAssignmentTarget`.
      1. NOTE: While binary AST distinguishes between array literals used as right-hand side expressions and used as left-hand side expressions, the ECMAScript lexical grammar deals with this via a cover grammar and reparsing. While it is preferable to transform `ArrayAssignmentTarget` directly to |ArrayAssignmentPattern|, doing so would require changing the ECMAScript spec to consume that production without reparsing.
      1. If _litArray_`.elements` has length 0, then
          1. Return |ArrayLiteral| : <emu-t>[</emu-t> <emu-t>]</emu-t>.
      1. Let and _elementList_ and _elisions_ be the results of ? ElementListEcmaify(_litArray_`.elements`).
      1. If _elementList_ is empty:
          1. Assert: _elisions_ is not empty.
          1. Return |ArrayLiteral| : <emu-t>[</emu-t> _elisions_ <emu-t>]</emu-t>.
      1. Else,
          1. If _elisions_ is empty, then return |ArrayLiteral| : <emu-t>[</emu-t> _elementList_ <emu-t>]</emu-t>.
          1. Else return |ArrayLiteral| : <emu-t>[</emu-t> _elementList_ <emu-t>,</emu-t> _elisions_ <emu-t>]</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyarrowexpression" aoid="EcmaifyArrowExpression">
    <h1>EcmaifyArrowExpression ( _litArrow_ )</h1>
    <emu-alg>
      1. NOTE: Arrow expressions are canonicalized to use parenthesized parameters and braced bodies.
      1. Assert: _litArrow_ is an `EagerArrowExpression` or a `LazyArrowExpression`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Let _params_ be ? LazyCoverArrowParameterListEcmaify(_litArrow_).
      1. Let _lazyBody_ be ? LazyFunctionBodyEcmaify(_litArrow_).
      1. Set the current asserted scope to _enclosingScope_.
      1. If _litArrow_`.isAsync` is *true*, then
          1. Let _asyncHead_ be |AsyncArrowHead| : <emu-t>async</emu-t> _params_.
          1. Let _asyncBody0_ be |AsyncFunctionBody| : _lazyBody_.
          1. Let _asyncBody_ be |AsyncConciseBody| : <emu-t>{</emu-t> _asyncBody0_ <emu-t>}</emu-t>.
          1. Return |AsyncArrowFunction| : _asyncHead_ <emu-t>=&gt;</emu-t> _asyncBody_.
      1. Else,
          1. Let _body_ be |ConciseBody| : <emu-t>{</emu-t> _lazyBody_ <emu-t>}</emu-t>.
          1. Return |ArrowFunction| : _params_ <emu-t>=&gt;</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyassignmentexpression" aoid="EcmaifyAssignmentExpression">
    <h1>EcmaifyAssignmentExpression ( _assign_ )</h1>
    <emu-alg>
      1. Assert: _assign_ is an `AssignmentExpression`.
      1. Let _lhs_ be ? LeftHandSideExpressionEcmaify(_assign_`.binding`).
      1. Let _rhs_ be ? AssignmentExpressionEcmaify(_assign_`.expression`).
      1. Return |AssignmentExpression| : _lhs_ <emu-t>=</emu-t> _rhs_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybinaryexpression" aoid="EcmaifyBinaryExpression">
    <h1>EcmaifyBinaryExpression ( _bin_ )</h1>
    <emu-alg>
      1. Assert: _bin_ is a `BinaryExpression`.
      1. If _bin_`.operator` is `","`, then
          1. Let _left_ be ? ExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ? AssignmentExpressionEcmaify(_bin_`.right`).
          1. Return |Expression| : _left_ <emu-t>,</emu-t> _right_.
      1. Else if _bin_`.operator` is `"||"`, then
          1. Let _left_ be ? LogicalOREcmaify(_bin_`.left`).
          1. Let _right_ be ? LogicalANDEcmaify(_bin_`.right`).
          1. Return |LogicalORExpression| : _left_ <emu-t>||</emu-t> _right_.
      1. Else if _bin_`.operator` is `"&&"`, then
          1. Let _left_ be ? LogicalANDEcmaify(_bin_`.left`).
          1. Let _right_ be ? BitwiseOREcmaify(_bin_`.right`).
          1. Return |LogicalANDExpression| : _left_ <emu-t>&&</emu-t> _right_.
      1. Else if _bin_`.operator` is `"|"`, then
          1. Let _left_ be ? BitwiseOREcmaify(_bin_`.left`).
          1. Let _right_ be ? BitwiseXOREcmaify(_bin_`.right`).
          1. Return |BitwiseORExpression| : _left_ <emu-t>`|`</emu-t> _right_.
      1. Else if _bin_`.operator` is `"^"`, then
          1. Let _left_ be ? BitwiseXOREcmaify(_bin_`.left`).
          1. Let _right_ be ? BitwiseANDEcmaify(_bin_`.right`).
          1. Return |BitwiseXORExpression| : _left_ <emu-t>^</emu-t> _right_.
      1. Else if _bin_`.operator` is `"&"`, then
          1. Let _left_ be ? BitwiseANDEcmaify(_bin_`.left`).
          1. Let _right_ be ? EqualityExpressionEcmaify(_bin_`.right`).
          1. Return |BitwiseANDExpression| : _left_ <emu-t>&</emu-t> _right_.
      1. Else if _bin_`.operator` is `"=="`, `"!="`, `"==="`, or `"!=="`, then
          1. Let _left_ be ? EqualityExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ? RelationalExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"=="`, then return |EqualityExpression| : _left_ <emu-t>==</emu-t> _right_.
          1. Else if _bin_`.operator` is `"!="`, then return |EqualityExpression| : _left_ <emu-t>!=</emu-t> _right_.
          1. Else if _bin_`.operator` is `"==="`, then return |EqualityExpression| : _left_ <emu-t>===</emu-t> _right_.
          1. Else return |EqualityExpression| : _left_ <emu-t>!==</emu-t> _right_.
      1. Else if _bin_`.operator` is `"<"`, `">"`, `"<="`, `">="`, `"instanceof"`, or `"in"`, then
          1. Let _left_ be ? RelationExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ? ShiftExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"<"` return |RelationalExpression| : _left_ <emu-t>&lt;</emu-t> _right_.
          1. Else if _bin_`.operator` is `">"`, then return |RelationalExpression| : _left_ <emu-t>&gt;</emu-t> _right_.
          1. Else if _bin_`.operator` is `"<="` return |RelationalExpression| : _left_ <emu-t>&lt;=</emu-t> _right_.
          1. Else if _bin_`.operator` is `">="`, then return |RelationalExpression| : _left_ <emu-t>&gt;=</emu-t> _right_.
          1. Else if _bin_`.operator` is `"instanceof"`, then return |RelationalExpression| : _left_ <emu-t>instanceof</emu-t> _right_.
          1. Else return |RelationalExpression| : _left_ <emu-t>in</emu-t> _right_.
      1. Else if _bin_`.operator` is `"<<"`, `">>"`, or `">>>"`, then
          1. Let _left_ be ? ShiftExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ? AdditiveExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"<<"`, then return |ShiftExpression| : _left_ <emu-t>&lt;&lt;</emu-t> _right_.
          1. Else if _bin_`.operator` is `">>"`, then return |ShiftExpression| : _left_ <emu-t>&gt;&gt;</emu-t> _right_.
          1. Else return |ShiftExpression| : _left_ <emu-t>&gt;&gt;&gt;</emu-t> _right_.
      1. Else if _bin_`.operator` is `"+"` or `"-"`, then
          1. Let _left_ be ? AdditiveExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ? MultiplicativeExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"+"`, then return |AdditiveExpression| : _left_ <emu-t>+</emu-t> _right_.
          1. Else return |AdditiveExpression| : _left_ <emu-t>-</emu-t> _right_.
      1. Else if _bin_`.operator` is `"*"`, `"/"`, or `"%"`, then
          1. Let _left_ be ? MultiplicativeExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ? ExponentationExpressionEcmaify(_bin_`.right`).
          1. Let _op_ be an empty Parse Node.
          1. If _bin_`.operator` is `"*"`, then set _op_ to |MultiplicativeOperator| : <emu-t>`*`</emu-t>
          1. Else if _bin_`.operator` is `"/"`, then set _op_ to |MultiplicativeOperator| : <emu-t>/</emu-t>.
          1. Else if _bin_`.operator` is `"%"`, then set _op_ to |MultiplicativeOperator| : <emu-t>%</emu-t>.
          1. Return |MultiplicativeExpression| : _left_ _op_ _right_.
      1. Else,
          1. Let _left_ be ? UpdateExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ? ExponentationExpressionEcmaify(_bin_`.right`).
          1. Return |ExponentiationExpression| : _left_ <emu-t>`**`</emu-t> _right_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycallexpression" aoid="EcmaifyCallExpression">
    <h1>EcmaifyCallExpression ( _call_ )</h1>
    <emu-alg>
      1. Assert: _call_ is a `CallExpression`.
      1. Let _args_ be ? ArgumentsEcmaify(_call_`.arguments`).
      1. If _call_.callee is a `Super`, then
          1. Let _superCall_ be |SuperCall| : <emu-t>super</emu-t> _args_.
          1. Return |CallExpression| : _superCall_.
      1. Else,
          1. NOTE: CallExpressions are canonicalized to have the callee to always be parenthesized.
          1. Let _callee_ be ? MemberExpressionEcmaify(_call_`.callee`).
          1. Return |CallExpression| : _callee_ _args_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecamifycompoundassignmentexpression" aoid="EcmaifyCompoundAssignmentExpression">
    <h1>EcmaifyCompoundAssignmentExpression ( _assign_ )</h1>
    <emu-alg>
      1. Assert: _assign_ is a `CompoundAssignmentExpression`.
      1. Let _lhs_ be ? LeftHandSideExpressionEcmaify(_assign_`.binding`)
      1. Let _rhs_ be ? AssignmentExpressionEcmaify(_assign_`.expression`).
      1. Let _op_ be an empty Parse Node.
      1. If _assign_`.operator` is `"|="` then set _op_ to |AssignmentOperator| : <emu-t>|=</emu-t>.
      1. Else if _assign_`.operator` is `"/="` then set _op_ to |AssignmentOperator| : <emu-t>/=</emu-t>.
      1. Else if _assign_`.operator` is `"%="` then set _op_ to |AssignmentOperator| : <emu-t>%=</emu-t>.
      1. Else if _assign_`.operator` is `"+="` then set _op_ to |AssignmentOperator| : <emu-t>+=</emu-t>.
      1. Else if _assign_`.operator` is `"-="` then set _op_ to |AssignmentOperator| : <emu-t>-=</emu-t>.
      1. Else if _assign_`.operator` is `"<<="` then set _op_ to |AssignmentOperator| : <emu-t><<=</emu-t>.
      1. Else if _assign_`.operator` is `">>="` then set _op_ to |AssignmentOperator| : <emu-t>>>=</emu-t>.
      1. Else if _assign_`.operator` is `">>>="` then set _op_ to |AssignmentOperator| : <emu-t>>>>=</emu-t>.
      1. Else if _assign_`.operator` is `"&="` then set _op_ to |AssignmentOperator| : <emu-t>&=</emu-t>.
      1. Else if _assign_`.operator` is `"^="` then set _op_ to |AssignmentOperator| : <emu-t>^=</emu-t>.
      1. Else if _assign_`.operator` is `"|="` then set _op_ to |AssignmentOperator| : <emu-t>|=</emu-t>.
      1. Else set _op_ to |AssignmentOperator| : <emu-t>&#42;&#42;=</emu-t>.
      1. Return |AssignmentExpression| : _lhs_ _op_ _rhs_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycomputedmemberexpression" aoid="EcmaifyComputedMemberExpression">
    <h1>EcmaifyComputedMemberExpression ( _getelem_ )</h1>
    <emu-alg>
      1. Assert: _getelem_ is a `ComputedMemberExpression` or a `ComputedMemberAssignmentTarget`.
      1. Let _expr_ be ? ExpressionEcmaify(_getelem_`.expression`).
      1. If _getelem_`._object` is a `Super`, then
          1. Let _superProp_ be |SuperProperty| : <emu-t>super</emu-t> <emu-t>[</emu-t> _expr_ <emu-t>]</emu-t>.
          1. Return |MemberExpression| : _superProp_.
      1. Else,
          1. Let _base_ be ? MemberExpressionEcmaify(_getelem_`._object`).
          1. Return |MemberExpression| : _base_ <emu-t>[</emu-t> _expr_ <emu-t>]</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyconditionalexpression" aoid="EcmaifyConditionalExpression">
    <h1>EcmaifyConditionalExpression ( _hook_ )</h1>
    <emu-alg>
      1. Assert: _hook_ is a `ConditionalExpression`.
      1. Let _test_ be ? LogicalORExpressionEcmaify(_hook_`.test`).
      1. Let _then_ be ? AssignmentExpressionEcmaify(_hook_`.consequent`).
      1. Let _else_ be ? AssignmentExpressionEcmaify(_hook_`.alternate`).
      1. Return |ConditionalExpression| : _test_ <emu-t>?</emu-t> _then_ <emu-t>:</emu-t> _else_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyclassexpression" aoid="EcmaifyClassExpression">
    <h1>EcmaifyClassExpression ( _cls_ )</h1>
    <emu-alg>
      1. Assert: _cls_ is a `ClassExpression`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyfunctionexpression" aoid="EcmaifyFunctionExpression">
    <h1>EcmaifyFunctionExpression ( _func_ )</h1>
    <emu-alg>
      1. Assert: _func_ is an `EagerFunctionExpression` or a `LazyFunctionExpression`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Let _maybeFuncName_ be an empty Parse Node.
      1. If _func_`.name` not *null*, then
          1. Set _maybeFuncName_ to ? Ecmaify(_func_`.name`).
          1. Perform MaybeSynthesizeNamedLambdaScope(_func_).
      1. Perform MaybeSynthesizeThisScope(_func_).
      1. Let _params_ be ? LazyFormalParametersEcmaify(_func_).
      1. If _func_`.isAsync` is *true*, then
          1. Let _body_ be |AsyncFunctionBody| : ? LazyFunctionBodyEcmaify(_func_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Return |AsyncFunctionExpression| : <emu-t>async</emu-t> <emu-t>function</emu-t> _maybeFuncName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else if _func_`.isGenerator` is *true*, then
          1. Let _body_ be |GeneratorBody| : ? LazyFunctionBodyEcmaify(_func_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Return |GeneratorExpression| : <emu-t>function</emu-t> <emu-t>`*`</emu-t> _maybeFuncName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else,
          1. Let _body_ be ? LazyFunctionBodyEcmaify(_func_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Return |FunctionExpression| : <emu-t>function</emu-t> _maybeFuncName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyidentifierexpression" aoid="EcmaifyIdentifierExpression">
    <h1>EcmaifyIdentifierExpression ( _ident_ )</h1>
    <emu-alg>
      1. Assert: _ident_ is an `IdentifierExpression`.
      1. If _ident_`.name` is `"yield"`, then return |IdentifierReference| : <emu-t>yield</emu-t>.
      1. Else if _ident_`.name` is `"await"`, then return |IdentifierReference| : <emu-t>await</emu-t>.
      1. Else return |IdentifierReference| : ? IdentifierEcmaify(_ident_`.name`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifynewexpression" aoid="EcmaifyNewExpression">
    <h1>EcmaifyNewExpression ( _new_ )</h1>
    <emu-alg>
      1. NOTE: New expressions are canonicalized to the arguments-taking verison.
      1. Assert: _new_ is a `NewExpression`.
      1. Let _callee_ be ? MemberExpressionEcmaify(_new_`.callee`).
      1. Let _args_ be ? ArgumentesEcmaify(_new_`.arguments`).
      1. Return |MemberExpression|: <emu-t>new</emu-t> _callee_ _args_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifynewtargetexpression" aoid="EcmaifyNewTargetExpression">
    <h1>EcmaifyNewTargetExpression ( _newTarget_ )</h1>
    <emu-alg>
      1. Assert: _newTarget_ is a `NewTargetExpression`.
      1. Let _n_ be |NewTarget| : <emu-t>new</emu-t> <emu-t>.</emu-t> <emu-t>target</emu-t>.
      1. Return |MetaProperty| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyobjectexpression" aoid="EcmaifyObjectExpression">
    <h1>EcmaifyObjectExpression ( _litObj_ )</h1>
    <emu-alg>
      1. Assert: _litObj_ is an `ObjectExpression` or an `ObjectAssignmentTarget`.
      1. NOTE: While binary AST distinguishes between object literals used as right-hand side expressions and used as left-hand side expressions, the ECMAScript lexical grammar deals with this via a cover grammar and reparsing. While it is preferable to transform `ObjectAssignmentTarget` directly to |ObjectAssignmentPattern|, doing so would require changing the ECMAScript spec to consume that production without reparsing.
      1. If _litObj_`.properties` has length 0, then return |ObjectLiteral| : <emu-t>{</emu-t> <emu-t>}</emu-t>.
      1. Else,
          1. Let _props_ be ? PropertyDefinitionListEcmaify(_litObj_`.properties`).
          1. Return |ObjectLiteral| : <emu-t>{</emu-t> _props_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyunaryexpression" aoid="EcmaifyUnaryExpression">
    <h1>EcmaifyUnaryExpression ( _unary_ )</h1>
    <emu-alg>
      1. Assert: _unary_ is an `UnaryExpression`.
      1. Let _operand_ be ? UnaryExpressionEcmaify(_unary_`.operand`).
      1. If _unary_`.operator` is "delete", then return |UnaryExpression| : <emu-t>delete</emu-t> _operand_.
      1. Else if _unary_`.operator` is "void", then return |UnaryExpression| : <emu-t>void</emu-t> _operand_.
      1. Else if _unary_`.operator` is "typeof", then return |UnaryExpression| : <emu-t>typeof</emu-t> _operand_.
      1. Else if _unary_`.operator` is "+", then return |UnaryExpression| : <emu-t>+</emu-t> _operand_.
      1. Else if _unary_`.operator` is "-", then return |UnaryExpression| : <emu-t>-</emu-t> _operand_.
      1. Else if _unary_`.operator` is "~", then return |UnaryExpression| : <emu-t>~</emu-t> _operand_.
      1. Else return |UnaryExpression| : <emu-t>!</emu-t> _operand_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifystaticmemberexpression" aoid="EcmaifyStaticMemberExpression">
    <h1>EcmaifyStaticMemberExpression ( _getprop_ )</h1>
    <emu-alg>
      1. Assert: _getprop_ is a `StaticMemberExpression` or a `StaticMemberAssignmentTarget`.
      1. If _getprop_`._object` is a `Super`, then
          1. Let _superProp_ be |SuperProperty| : <emu-t>super</emu-t> <emu-t>.</emu-t> _getprop_`.property`.
          1. Return |MemberExpression| : _superProp_.
      1. Else,
          1. Let _base_ be ? MemberExpressionEcmaify(_getprop_`._object`).
          1. Return |MemberExpression| : _base_ <emu-t>.</emu-t> _getprop_`.property`.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifytemplateexpression" aoid="EcmaifyTemplateExpression">
    <h1>EcmaifyTemplateExpression ( _litTemplate_ )</h1>
    <emu-alg>
      1. Assert: _litTemplate_ is a `TemplateExpression`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifythisexpression" aoid="EcmaifyThisExpression">
    <h1>EcmaifyThisExpression ( _this_ )</h1>
    <emu-alg>
      1. Assert: _this_ is a `ThisExpression`.
      1. Return |PrimaryExpression| : <emu-t>this</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyupdateexpression" aoid="EcmaifyUpdateExpression">
    <h1>EcmaifyUpdateExpression ( _upd_ )</h1>
    <emu-alg>
      1. Assert: _upd_ is an `UpdateExpression`.
      1. If _upd_`.isPrefix` is *true*, then
          1. Let _operand_ be ? UnaryExpressionEcmaify(_upd_`.operand`).
          1. If _upd_`.operator` is `"++"`, then return |UpdateExpression| : <emu-t>++</emu-t> _operand_.
          1. Else return |UpdateExpression| : <emu-t>--</emu-t> _operand_.
      1. Else,
          1. Let _operand_ be ? LeftHandSideExpressionEcmaify(_upd_`.operand`).
          1. If _upd_`.operator` is `"++"`, then return |UpdateExpression| : _operand_ <emu-t>++</emu-t>.
          1. Else return |UpdateExpression| : _operand_ <emu-t>--</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyyieldexpression" aoid="EcmaifyYieldExpression">
    <h1>EcmaifyYieldExpression ( _yield_ )</h1>
    <emu-alg>
      1. Assert: _yield_ is a `YieldExpression`.
      1. If _yield_`.expression` is null, then
          1. Return |YieldExpression| : <emu-t>yield</emu-t>.
      1. Else,
          1. Let _expr_ be ? AssignmentExpressionEcmaify(_yield_`.expression`).
          1. Return |YieldExpression| : <emu-t>yield</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyyieldstarexpression" aoid="EcmaifyYieldStarExpression">
    <h1>EcmaifyYieldStarExpression ( _yieldStart_ )</h1>
    <emu-alg>
      1. Assert: _yieldStar_ is a `YieldStarExpression`.
      1. Let _expr_ be ? AssignmentExpressionEcmaify(_yieldStar_`.expression`).
      1. Return |YieldExpression| : <emu-t>yield</emu-t> <emu-t>`*`</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyawaitexpression" aoid="EcmaifyAwaitExpression">
    <h1>EcmaifyAwaitExpression ( _await_ )</h1>
    <emu-alg>
      1. Assert: _await_ is an `AwaitExpression`.
      1. Let _expr_ be ? UnaryExpressionEcmaify(_await_`.expression`).
      1. Return |AwaitExpression| : <emu-t>await</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycomputedpropertyname" aoid="EcmaifyComputedPropertyName">
    <h1>EcmaifyComputedPropertyName ( _name_ )</h1>
    <emu-alg>
      1. Assert: _name_ is a `ComputedPropertyName`.
      1. Let _expr_ be ? AssignmentExpressionEcmaify(_name_`.expression`).
      1. Return |ComputedPropertyName| : <emu-t>[</emu-t> _expr_ <emu-t>]</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralpropertyname" aoid="EcmaifyLiteralPropertyName">
    <h1>EcmaifyLiteralPropertyName ( _name_ )</h1>
    <emu-alg>
      1. NOTE: Literal property names are canonicalized to double quoted string literals.
      1. Assert: _name_ is a `LiteralPropertyName`.
      1. If _name_`.value` is the empty string, then throw a *SyntaxError* exception.
      1. Let _v_ be the value of _name_`.value` escaped for double quotes.
      1. Let _l_ be |StringLiteral| : <emu-t>"</emu-t> _v_ <emu-t>"</emu-t>.
      1. Return |LiteralPropertyName| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifymethod" aoid="EcmaifyMethod">
    <h1>EcmaifyMethod ( _method_ )</h1>
    <emu-alg>
      1. Assert: _method_ is an `EagerMethod` or a `LazyMethod`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Perform MaybeSynthesizeThisScope(_func_).
      1. Let _name_ be |PropertyName| : ? Ecmaify(_method_`.name`).
      1. Let _params_ be |UniqueFormalParameters| : ? LazyFormalParametersEcmaify(_method_).
      1. If _method_`.isAsync` is |true|, then
          1. Let _body_ be |AsyncFunctionBody| : ? LazyFunctionBodyEcmaify(_method_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Let _m_ be |AsyncMethod| : <emu-t>async</emu-t> _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Return |MethodDefinition| : _m_.
      1. Else if _method_`.isGenerator` is |true|, then
          1. Let _body_ be |GeneratorBody| : ? LazyFunctionBodyEcmaify(_method_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Let _m_ |GeneratorMethod| : <emu-t>`*`</emu-t> _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Return |MethodDefinition| : _m_.
      1. Else,
          1. Let _body_ be ? LazyFunctionBodyEcmaify(_method_).
          1. Set the current asserted scope to _enclosingScope_.
          1. Return |MethodDefinition| : _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifygetter" aoid="EcmaifyGetter">
    <h1>EcmaifyGetter ( _getter_ )</h1>
    <emu-alg>
      1. Assert: _getter_ is an `EagerGetter` or a `LazyGetter`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Let _name_ be |PropertyName| : ? Ecmaify(_getter_`.name`).
      1. Perform MaybeSynthesizeThisScope(_func_).
      1. Let _body_ be ? LazyFunctionBodyEcmaify(_getter_).
      1. Set the current asserted scope to _enclosingScope_.
      1. Return |MethodDefinition| : <emu-t>get</emu-t> _name_ <emu-t>(</emu-t> <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifysetter" aoid="EcmaifySetter">
    <h1>EcmaifySetter ( _setter_ )</h1>
    <emu-alg>
      1. Assert: _setter_ is an `EagerSetter` or a `LazySetter`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Let _name_ be |PropertyName| : ? Ecmaify(_setter_`.name`).
      1. Perform MaybeSynthesizeThisScope(_func_).
      1. Let _param_ be ? LazyPropertySetParameterListEcmaify(_setter_`.param`).
      1. Let _body_ be ? LazyFunctionBodyEcmaify(_setter_).
      1. Set the current asserted scope to _enclosingScope_.
      1. Return |MethodDefinition| : <emu-t>set</emu-t> _name_ <emu-t>(</emu-t> _param_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifydataproperty" aoid="EcmaifyDataProperty">
    <h1>EcmaifyDataProperty ( _prop_ )</h1>
    <emu-alg>
      1. Assert: _prop_ is a `DataProperty`.
      1. Let _name_ be |PropertyName| : ? Ecmaify(_prop_`.name`).
      1. Let _expr_ be ? AssignmentExpressionEcmaify(_prop_`.expression`).
      1. Return |PropertyDefinition| : _name_ <emu-t>:</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyshorthandproperty" aoid="EcmaifyShorthandProperty">
    <h1>EcmaifyShorthandProperty ( _prop_ )</h1>
    <emu-alg>
      1. Assert: _prop_ is a `ShorthandProperty`.
      1. Let _ident_ be ? Ecmaify(_prop_`.name`).
      1. Return |PropertyDefinition| : _ident_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybindingidentifier" aoid="EcmaifyBindingIdentifier">
    <h1>EcmaifyBindingIdentifier ( _b_ )</h1>
    <emu-alg>
      1. Assert: _b_ is a `BindingIdentifier`.
      1. If _b_`.name` is `"yield"`, then return |BindingIdentifier| : <emu-t>yield</emu-t>.
      1. Else if _b_`.name` is `"await"`, then return |BindingIdentifier| : <emu-t>await</emu-t>.
      1. Else return |BindingIdentifier| : ? IdentifierEcmaify(_b_`.name`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyobjectbinding" aoid="EcmaifyObjectBinding">
    <h1>EcmaifyObjectBinding ( _obj_ )</h1>
    <emu-alg>
      1. Assert: _obj_ is an `ObjectBinding`.
      1. If _obj_`.properties` has length 0, then return |ObjectBindingPattern| : <emu-t>{</emu-t> <emu-t>}</emu-t>.
      1. Else return |ObjectBindingPattern| : <emu-t>{</emu-t> ? BindingPropertyListEcmaify(_obj_`.properties`) <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybindingpropertyidentifier" aoid="EcmaifyBindingPropertyIdentifier">
    <h1>EcmaifyBindingPropertyIdentifier ( _nameBinding_ )</h1>
    <emu-alg>
      1. Assert: _nameBinding_ is a `BindingPropertyIdentifier`.
      1. Let _binding_ be ? BindingIdentifierEcmaify(_nameBinding_`.binding`).
      1. Let _init_ be an empty Parse Node.
      1. If _nameBinding_`.init` is not *null*, then set _init_ to ? InitializerEcmaify(_nameBinding_`.init`).
      1. Let _singleNameBinding_ be |SingleNameBinding| : _binding_ _init_.
      1. Return |BindingProperty| : _singleNameBinding_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybindingproperty" aoid="EcmaifyBindingPropertyProperty">
    <h1>EcmaifyBindingPropertyProperty ( _propBinding_ )</h1>
    <emu-alg>
      1. Assert: _propBinding_ is a `BindingPropertyProperty`.
      1. Let _propName_ be |PropertyName| : ? Ecmaify(_propBinding_`.name`).
      1. Let _binding_ be ? BindingElementEcmaify(_propBinding_`.binding).
      1. Return |BindingProperty| : _propName_ <emu-t>:</emu-t> _binding_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyarraybinding" aoid="EcmaifyArrayBinding">
    <h1>EcmaifyArrayBinding ( _arr_ )</h1>
    <emu-alg>
      1. Assert: _arr_ is an `ArrayBinding`.
      1. If _arr_`.elements` has length 0, then
          1. If _arr_`.rest` is *null*, then return |ArrayBindingPattern| : <emu-t>[</emu-t> <emu-t>]</emu-t>.
          1. Else,
              1. Let _restElem_ be ? BindingRestElementEcmaify(_arr_`.rest`).
              1. Return |ArrayBindingPattern| : <emu-t>[</emu-t> _restElem_ <emu-t>]</emu-t>.
      1. Let _elemList_ and _elisions_ be the results of ? BindingElementListEcmaify(_arr_`.elements`).
      1. If _elemList_ is empty, then
          1. If _arr_`.rest` is *null*, then throw a *SyntaxError* exception.
          1. Else,
              1. Let _restElem_ be ? BindingRestElementEcmaify(_arr_`.rest`).
              1. Return |ArrayBindingPattern| : <emu-t>[</emu-t> _elisions_ _restElem_ <emu-t>]</emu-t>.
      1. Else,
          1. If _arr_`.rest` is *null*, then
              1. If _elisions_ is not empty, then throw a *SyntaxError* exception.
              1. Return |ArrayBindingPattern| : <emu-t>[</emu-t> _elemList_ <emu-t>]</emu-t>.
          1. Else,
              1. Let _restElem_ be ? BindingRestElementEcmaify(_arr_`.rest`).
              1. Return |ArrayBindingPattern| : <emu-t>[</emu-t> _elemList_ _elisions_ _restElem_ <emu-t>]</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybindingwithinitializer" aoid="EcmaifyBindingWithInitializer">
    <h1>EcmaifyBindingWithInitializer ( _bindingWithInit_ )</h1>
    <emu-alg>
      1. Assert: _bindingWithInit_ is a `BindingWithInitializer`.
      1. Let _binding_ be ? Ecmaify(_binding_`.binding`).
      1. Let _init_ be ? InitializerEcmaify(_binding_`.init`).
      1. If _bindingWithInit_`.binding` is a `BindingIdentifier`, then
          1. Let _singleNameBinding_ be |SingleNameBinding| : _binding_ _init_.
          1. Return |BindingElement| : _singleNameBinding_.
      1. Else return |BindingElement| : _binding_ _init_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyassignmenttargetwithinitializer" aoid="EcmaifyAssignmentTargetWithInitializer">
    <h1>EcmaifyAssignmentTargetWithInitializer ( _assignTargetWithInit_ )</h1>
    <emu-alg>
      1. Assert: _assignTargetWithInit_ is an `AssignmentTargetWithInitializer`.
      1. Let _lhs_ be LeftHandSideExpression(_assignTargetWithInit_`.binding`).
      1. Let _rhs_ be AssignmentExpression(_assignTargetWithInit_`.init`).
      1. Return |AssignmentExpression| : _lhs_ <emu-t>=</emu-t> _rhs_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyassignmenttargetpropertyidentifier" aoid="EcmaifyAssignmentTargetPropertyIdentifier">
    <h1>EcmaifyAssignmentTargetPropertyIdentifier ( _assignPropIdent_ )</h1>
    <emu-alg>
      1. Assert: _assignPropIdent_ is an `AssignmentTargetPropertyIdentifier`.
      1. Let _ident_ be ? IdentifierReferenceEcmaify(_assignPropIdent_`.binding.name`).
      1. Let _propDef0_ be an empty Parse Node.
      1. If _assignPropIdent_`.init` is not *null*, then
          1. Let _init_ be ? InitializerEcmaify(_assignPropIdent_`.init`).
          1. Set _propDef0_ to |CoverInitializedName| : _ident_ _init_.
      1. Else set _propDef0_ to _ident_.
      1. Return |PropertyDefinition| : _propDef0_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyassignmenttargetpropertyproperty" aoid="EcmaifyAssignmentTargetPropertyProperty">
    <h1>EcmaifyAssignmentTargetPropertyProperty ( _assignPropProp_ )</h1>
    <emu-alg>
      1. Assert: _assignPropProp_ is an `AssignmentTargetPropertyProperty`.
      1. Let _propName_ be |PropertyName| : ? Ecmaify(_assignPropProp_`.name`).
      1. Let _assignExpr_ be ? AssignmentExpressionEcmaify(_assignProp_`.binding`).
      1. Return |PropertyDefinition| : _propName_ <emu-t>:</emu-t> _assignExpr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforinofbinding" aoid="EcmaifyForInOfBinding">
    <h1>EcmaifyForInOfBinding ( _b_ )</h1>
    <emu-alg>
      1. Assert: _b_ is a `ForInOfBinding`.
      1. Assert: _b_`.kind` is not `"var"`.
      1. Let _binding_ be |ForBinding| : ? Ecmaify(_b_`.binding`).
      1. Else return |ForDeclaration| : ? Ecmaify(_b_`.kind`) _binding_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyparameter" aoid="EcmaifyParameter">
    <h1>EcmaifyParameter ( _param_ )</h1>
    <emu-alg>
      1. Assert: _param_ is a `Parameter`.
      1. Return |FormalParameter| : ? BindingElementEcmaify(_param_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycatchclause" aoid="EcmaifyCatchClause">
    <h1>EcmaifyCatchClause ( _catchClause_ )</h1>
    <emu-alg>
      1. Assert: _catchClause_ is a `CatchClause`.
      1. Let _enclosingScope_ be the current asserted scope.
      1. Set the current asserted scope to _catchClause_`.bindingScope`.
      1. Perform AddAssertedScopeTreeNode(_catchClause_`.bindingScope`, _enclosingScope_).
      1. Let _binding_ be ? Ecmaify(_catchClause_`.binding`).
      1. Let _body_ be ? Ecmaify(_catchClause_`.body`).
      1. Let _catch_ be |Catch| : <emu-t>catch</emu-t> <emu-t>(</emu-t> _binding_ <emu-t>)</emu-t> _body_.
      1. Perform ? CheckAssertedScope(_catchClause_`.bindingScope`, _catch_).
      1. Set the current asserted scope to _enclosingScope_.
      1. Return _catch_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyvariabledeclarationkind" aoid="EcmaifyVariableDeclarationKind">
    <h1>EcmaifyVariableDeclarationKind ( _k_ )</h1>
    <emu-alg>
      1. Assert: _k_ is `"let"` or `"const"`.
      1. If _k_ is `"let"`, then return |LetOrConst| : <emu-t>let</emu-t>.
      1. Else return |LetOrConst| : <emu-t>const</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaify" aoid="Ecmaify">
    <h1>Ecmaify ( _node_ )</h1>
    <emu-alg>
      1. Assert: _node_ is a `Node`.
      1. If _node_ is a `Block`, then return ? EcmaifyBlock(_node_).
      1. Else if _node_ is a `BreakStatement`, then return ? EcmaifyBreakStatement(_node_).
      1. Else if _node_ is a `ContinueStatement`, then return ? EcmaifyContinueStatement(_node_).
      1. Else if _node_ is a `ClassDeclaration`, then return ? EcmaifyClassDeclaration(_node_).
      1. Else if _node_ is a `DebuggerStatement`, then return ? EcmaifyDebuggerStatement(_node_).
      1. Else if _node_ is a `EmptyStatement`, then return ? EcmaifyEmptyStatement(_node_).
      1. Else if _node_ is a `ExpressionStatement`, then return ? EcmaifyExpressionStatement(_node_).
      1. Else if _node_ is a `FunctionDeclaration`, then return ? EcmaifyFunctionDeclaration(_node_).
      1. Else if _node_ is a `IfStatement`, then return ? EcmaifyIfStatement(_node_).
      1. Else if _node_ is a `DoWhileStatement`, then return ? EcmaifyDoWhileStatement(_node_).
      1. Else if _node_ is a `ForInStatement`, then return ? EcmaifyForInStatement(_node_).
      1. Else if _node_ is a `ForOfStatement`, then return ? EcmaifyForOfStatement(_node_).
      1. Else if _node_ is a `ForStatement`, then return ? EcmaifyForStatement(_node_).
      1. Else if _node_ is a `WhileStatement`, then return ? EcmaifyWhileStatement(_node_).
      1. Else if _node_ is a `LabelledStatement`, then return ? EcmaifyLabelledStatement(_node_).
      1. Else if _node_ is a `ReturnStatement`, then return ? EcmaifyReturnStatement(_node_).
      1. Else if _node_ is a `SwitchStatement`, then return ? EcmaifySwitchStatement(_node_).
      1. Else if _node_ is a `SwitchStatementWithDefault`, then return ? EcmaifySwitchStatementWithDefault(_node_).
      1. Else if _node_ is a `ThrowStatement`, then return ? EcmaifyThrowStatement(_node_).
      1. Else if _node_ is a `TryCatchStatement`, then return ? EcmaifyTryCatchStatement(_node_).
      1. Else if _node_ is a `TryFinallyStatement`, then return ? EcmaifyTryFinallyStatement(_node_).
      1. Else if _node_ is a `VariableDeclaration`, then return ? EcmaifyVariableDeclaration(_node_).
      1. Else if _node_ is a `WithStatement`, then return ? EcmaifyWithStatement(_node_).
      1. Else if _node_ is a `LiteralBooleanExpression`, then return ? EcmaifyLiteralBooleanExpression(_node_).
      1. Else if _node_ is a `LiteralInfinityExpression`, then return ? EcmaifyLiteralInfinityExpression(_node_).
      1. Else if _node_ is a `LiteralNullExpression`, then return ? EcmaifyLiteralNullExpression(_node_).
      1. Else if _node_ is a `LiteralNumericExpression`, then return ? EcmaifyLiteralNumericExpression(_node_).
      1. Else if _node_ is a `LiteralStringExpression`, then return ? EcmaifyLiteralStringExpression(_node_).
      1. Else if _node_ is a `LiteralRegExpExpression`, then return ? EcmaifyLiteralRegExpExpression(_node_).
      1. Else if _node_ is a `ArrayExpression`, then return ? EcmaifyArrayExpression(_node_).
      1. Else if _node_ is a `ArrowExpression`, then return ? EcmaifyArrowExpression(_node_).
      1. Else if _node_ is a `AssignmentExpression`, then return ? EcmaifyAssignmentExpression(_node_).
      1. Else if _node_ is a `BinaryExpression`, then return ? EcmaifyBinaryExpression(_node_).
      1. Else if _node_ is a `CallExpression`, then return ? EcmaifyCallExpression(_node_).
      1. Else if _node_ is a `CompoundAssignmentExpression`, then return ? EcmaifyCompoundAssignmentExpression(_node_).
      1. Else if _node_ is a `ComputedMemberExpression`, then return ? EcmaifyComputedMemberExpression(_node_).
      1. Else if _node_ is a `ConditionalExpression`, then return ? EcmaifyConditionalExpression(_node_).
      1. Else if _node_ is a `ClassExpression`, then return ? EcmaifyClassExpression(_node_).
      1. Else if _node_ is a `FunctionExpression`, then return ? EcmaifyFunctionExpression(_node_).
      1. Else if _node_ is a `IdentifierExpression`, then return ? EcmaifyIdentifierExpression(_node_).
      1. Else if _node_ is a `NewExpression`, then return ? EcmaifyNewExpression(_node_).
      1. Else if _node_ is a `NewTargetExpression`, then return ? EcmaifyNewTargetExpression(_node_).
      1. Else if _node_ is a `ObjectExpression`, then return ? EcmaifyObjectExpression(_node_).
      1. Else if _node_ is a `UnaryExpression`, then return ? EcmaifyUnaryExpression(_node_).
      1. Else if _node_ is a `StaticMemberExpression`, then return ? EcmaifyStaticMemberExpression(_node_).
      1. Else if _node_ is a `TemplateExpression`, then return ? EcmaifyTemplateExpression(_node_).
      1. Else if _node_ is a `ThisExpression`, then return ? EcmaifyThisExpression(_node_).
      1. Else if _node_ is a `UpdateExpression`, then return ? EcmaifyUpdateExpression(_node_).
      1. Else if _node_ is a `YieldExpression`, then return ? EcmaifyYieldExpression(_node_).
      1. Else if _node_ is a `YieldStarExpression`, then return ? EcmaifyYieldStarExpression(_node_).
      1. Else if _node_ is a `AwaitExpression`, then return ? EcmaifyAwaitExpression(_node_).
      1. Else if _node_ is a `ComputedPropertyName`, then return ? EcmaifyComputedPropertyName(_node_).
      1. Else if _node_ is a `LiteralPropertyName`, then return ? EcmaifyLiteralPropertyName(_node_).
      1. Else if _node_ is a `LiteralPropertyName`, then return ? EcmaifyLiteralPropertyName(_node_).
      1. Else if _node_ is a `Method`, then return ? EcmaifyMethod(_node_).
      1. Else if _node_ is a `Getter`, then return ? EcmaifyGetter(_node_).
      1. Else if _node_ is a `Setter`, then return ? EcmaifySetter(_node_).
      1. Else if _node_ is a `DataProperty`, then return ? EcmaifyDataProperty(_node_).
      1. Else if _node_ is a `ShorthandProperty`, then return ? EcmaifyShorthandProperty(_node_).
      1. Else if _node_ is a `ExportAllFrom`, then return ? EcmaifyExportAllFrom(_node_).
      1. Else if _node_ is a `ExportFrom`, then return ? EcmaifyExportFrom(_node_).
      1. Else if _node_ is a `ExportLocals`, then return ? EcmaifyExportLocals(_node_).
      1. Else if _node_ is a `ExportDefault`, then return ? EcmaifyExportDefault(_node_).
      1. Else if _node_ is a `ExportFromSpecifier`, then return ? EcmaifyExportFromSpecifier(_node_).
      1. Else if _node_ is a `ExportLocalSpecifier`, then return ? EcmaifyExportLocalSpecifier(_node_).
      1. Else if _node_ is a `Export`, then return ? EcmaifyExport(_node_).
      1. Else if _node_ is a `ImportSpecifier`, then return ? EcmaifyImportSpecifier(_node_).
      1. Else if _node_ is a `ImportNamespace`, then return ? EcmaifyImportNamespace(_node_).
      1. Else if _node_ is a `Import`, then return ? EcmaifyImport(_node_).
      1. Else if _node_ is a `BindingIdentifier`, then return ? EcmaifyBindingIdentifier(_node_).
      1. Else if _node_ is a `ObjectBinding`, then return ? EcmaifyObjectBinding(_node_).
      1. Else if _node_ is a `BindingPropertyIdentifier`, then return ? EcmaifyBindingPropertyIdentifier(_node_).
      1. Else if _node_ is a `BindingPropertyProperty`, then return ? EcmaifyBindingPropertyProperty(_node_).
      1. Else if _node_ is a `ArrayBinding`, then return ? EcmaifyArrayBinding(_node_).
      1. Else if _node_ is a `BindingWithInitializer`, then return ? EcmaifyBindingWithInitializer(_node_).
      1. NOTE: Some `AssignmentTarget` nodes are transformed as expressions instead of the cover grammar variant as the ECMAScript spec does reparsing.
      1. Else if _node_ is a `AssignmentTargetIdentifier`, then return ? EcmaifyAssignmentTargetIdentifierExpression(_node_).
      1. Else if _node_ is a `AssignmentTargetWithInitializer`, then return ? EcmaifyAssignmentTargetWithInitializer(_node_).
      1. Else if _node_ is a `ComputedMemberAssignmentTarget`, then return ? EcmaifyComputedMemberExpression(_node_).
      1. Else if _node_ is a `StaticMemberAssignmentTarget`, then return ? EcmaifyStaticMemberExpression(_node_).
      1. Else if _node_ is a `ObjectAssignmentTarget`, then return ? EcmaifyObjectExpression(_node_).
      1. Else if _node_ is a `AssignmentTargetPropertyIdentifier`, then return ? EcmaifyAssignmentTargetPropertyIdentifier(_node_).
      1. Else if _node_ is a `AssignmentTargetPropertyProperty`, then return ? EcmaifyAssignmentTargetPropertyProperty(_node_).
      1. Else if _node_ is a `ArrayAssignmentTarget`, then return ? EcmaifyArrayExpression(_node_).
      1. Else if _node_ is a `ClassElement`, then return ? EcmaifyClassElement(_node_).
      1. Else if _node_ is a `ForInOfBinding`, then return ? EcmaifyForInOfBinding(_node_).
      1. Else return ? EcmaifyDirective(_node_).
    </emu-alg>
  </emu-clause>

</emu-clause>

<emu-clause id="binast-evaluation">
  <h1>Evaluation</h1>
  <p>Binary AST is evaluated via the modified ScriptEvaluationJob and TopLevelModuleEvaluationJob, defined below. The binary AST is transformed into an ECMAScript parse tree. The resulting parse tree is then evaluated using the same evaluation semantics as for parse trees resulting from source text, with the following exceptions.</p>
  <ol>
    <li>Transformation of binary ASTs to parse trees may throw exceptions in the same phase as early errors.</li>
    <li>Evaluation of a binary AST is inherently lazy at the function boundaries. A function's |FunctionBody| is not transformed until it is invoked. This means Static Semantics which would have been observable (i.e. by throwing exceptions) at parse time of functions evaluated via source text is deferred until invocation if the function is evaluated via binary AST.</li>
  </ol>

  <emu-clause id="sec-assertions">
    <h1>Assertions</h1>
    <p>Evaluation of binary AST is possibly lazy at function boundaries. Together with `AssertedScope`, the intent is to allow implementations to start to start code generation without parsing the entire tree. `AssertedScope` represent assertions that must be checked. A failing assertion throws a *SyntaxError* exception.</p>
    <p>Asserted declared names must match exactly the set of actual declared names exactly in the scope. The asserted captured names in the scope must be a superset of observed captured names. If the presence of direct eval is asserted to be *false*, then a direct eval must not be observed in the scope. If the presence of direct eval is asserted to be *true*, a direct eval is allowed to not be observed (i.e. it is conservative).</p>
    <emu-note>While asserte scopes are optional, an implementation is prohibited from binding optimizations if they are absent.</emu-note>

    <p>The <dfn id="globalassertedscopetree">GlobalAssertedScopeTree</dfn> is a List that is globally available. It is shared by all realms. Prior to the evaluation of any ECMAScript code it is initialized as a new empty List. Elements of the GlobalAssertedScopeTree are Records with the structure defined in <emu-xref href="#table-assertedscopetreenode" title></emu-xref>.</p>

    <emu-table id="table-assertedscopetreenode" caption="AssertedScopeTreeNode Record Fields">
      <table>
        <tbody>
        <tr>
          <th>
            Field Name
          </th>
          <th>
            Value
          </th>
          <th>
            Meaning
          </th>
        </tr>
        <tr>
          <td>
            [[AssertedScope]]
          </td>
          <td>
            An `AssertedBlockScope`, `AssertedScriptGlobalScope`, `AssertedVarScope`, `AssertedParameterScope`, or `AssertedBoundNamesScope`
          </td>
          <td>
            The payload.
          </td>
        </tr>
        <tr>
          <td>
            [[Enclosing]]
          </td>
          <td>
            An AssertedScopeTreeNode Record or *null*
          </td>
          <td>
            The directly enclosing scope.
          </td>
        </tr>
        </tbody>
      </table>
    </emu-table>

    <emu-clause id="sec-findassertedscopetreenode" aoid="FindAssertedScopeTreeNode">
      <h1>FindAssertedScopeTreeNode ( _scope_ )</h1>
      <emu-alg>
        1. Assert: _scope_ is not *null*.
        1. For each _node_ in GlobalAssertedScopeTree, do
            1. If _node_.[[AssertedScope]] has the same identity as _scope_, then return _node_.
        1. Return *null*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-addassertedscopetreenode" aoid="AddAssertedScopeTreeNode">
      <h1>AddAssertedScopeTreeNode ( _scope_, _enclosing_ )</h1>
      <emu-alg>
        1. Let _found_ be FindAssertedScopeTreeNode(_scope_).
        1. If _found_ is not *null*, then
            1. If _enclosing_ is *null*, then
                1. Assert: _found_.[[Enclosing]] is *null*.
            1. Else,
                1. Let _enclosingNode_ be FindAssertedScopeTreeNode(_enclosing_).
                1. Assert: _found_.[[Enclosing]] has the same identity as _enclosingNode_.
        1. Else,
            1. Let _node_ be a new AssertedScopeTreeNode Record {[[AssertedScope]]: _scope_, [[Enclosing]]: _enclosingNode_}.
            1. Add _node_ as the last element of GlobalAssertedScopeTree.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-checkdeclarednames" aoid="CheckDeclaredNames">
      <h1>CheckDeclaredNames ( _expectedDeclared_, _kind_, _actualDeclared_ )</h1>
      <emu-alg>
        1. Let _unseen_ be a new empty List.
        1. For each _d_ in _expectedDeclared_, do
            1. If _d_`.kind` is _kind_, then add _d_`.name` as the last element of _unseen_.
        1. For each _dn_ in _actualDeclared_, do
            1. If _dn_ is not in _unseen_, then throw a *SyntaxError* exception.
            1. Remove _dn_ from _unseen_.
        1. If _unseen_ has length greater than 0, then throw a *SyntaxError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-checkparameternames" aoid="CheckParameterNames">
      <h1>CheckParameterNames ( _expectedParams0_, _actualParams_ )</h1>
      <emu-alg>
        1. Let _expectedParams_ be a new empty List.
        1. For each _p_ in _expectedParams0_, do
            1. Add _p_`.name` as the last element of _expectedParams_.
        1. Let _idx_ be 0.
        1. If _expectedParams_ and _actualParams_ have different lengths, then throw a *SyntaxError* exception.
        1. For each _pn_ in _actualParams_ in List order, do
            1. If _expectedParams_`[idx]` is not _pn_, then throw a *SyntaxError* exception.
            1. Set _idx_ to _idx_ + 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-checkboundnames" aoid="CheckBOundNames">
      <h1>CheckBoundNames ( _expectedBound_, _actualBound_ )</h1>
      <emu-alg>
        1. Let _unseen_ be a new empty List.
        1. For each _b_ in _expectedBound_, do
            1. Add _b_`.name` as the last element of _unseen_.
        1. For each _dn_ in _actualBound_, do
            1. If _dn_ is not in _unseen_, then throw a *SyntaxError* exception.
            1. Remove _dn_ from _unseen_.
        1. If _unseen_ has length greater than 0, then throw a *SyntaxError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-checkassertedscope" aoid="CheckAssertedScope">
      <h1>CheckAssertedScope ( _scope_ , _parseTree_ )</h1>
      <emu-alg>
        1. Assert: _scope_ is an `AssertedBlockScope` or an `AssertedScriptGlobalScope` or an `AssertedVarScope` or an `AssertedParameterScope` or an `AssertedBoundNamesScope`.
        1. Assert: _parseTree_ is a non-empty Parse Node.
        1. NOTE: All asserted declared names must be declared, and all asserted bound names must be bound.
        1. If _scope_ is an `AssertedBlockScope` or an `AssertedScriptGlobalScope` or an `AssertedVarScope`, then
            1. Let _varDeclaredNames_ be the VarDeclaredNames of _parseTree_.
            1. Perform ? CheckDeclaredNames(_scope_`.declaredNames`, `"var"`, _varDeclaredNames_).
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _parseTree_.
            1. Let _constLexicallyDeclaredNames_ be a new empty List.
            1. Let _nonConstLexicallyDeclaredNames_ be a new empty List.
            1. For each _d_ in _lexDeclarations_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                    1. Append to _constLexicallyDeclaredNames_ the elements of BoundNames of _d_.
                1. Else,
                    1. Append to _nonConstLexicallyDeclaredNames_ the elements of BoundNames of _d_.
            1. Perform ? CheckDeclaredNames(_scope_`.declaredNames`, `"const lexical"`, _constLexicallyDeclaredNames_).
            1. Perform ? CheckDeclaredNames(_scope_`.declaredNames`, `"non-const lexical"`, _nonConstLexicallyDeclaredNames_).
        1. Else if _scope_ is an `AssertedParameterScope`, then
            1. NOTE: The positions as well as the names of parameters must match.
            1. Let _paramNames_ be the BoundNames of _parseTree_.
            1. Perform ? CheckParameterNames(_scope_`.boundNames`, _boundNames_).
            1. If _scope_`.isSimpleParameterList` is not the same value as IsSimpleParameterList of _parseTree_, then throw a *SyntaxError* exception.
        1. Else,
            1. Let _boundNames_ be the BoundNames of _parseTree_.
            1. Perform ? CheckBoundNames(_scope_`.boundNames`, _boundNames_).
        1. NOTE: All free names must have been asserted both declared and captured in an enclosing scope. Non-captured declared names cannot shadow a captured declared name, as in source text. It is permitted to assert a declared name as captured even if it is never observed to be captured.
        1. Let _freeNames_ be the FreeNames of _parseTree_.
        1. For each _fn_ in _freeNames_, do
            1. Let _scopeNode_ be FindAssertedScopeTreeNode(_scope_).
            1. Let _outermostScope_ be *null*.
            1. Let _foundAssertedCapture_ be *false*.
            1. Repeat, while _scopeNode_.[[Enclosing]] is not *null* and _foundAssertedCapture_ is *false*,
                1. Let _enclosingScope_ be _scopeNode_.[[Enclosing]].[[AssertedScope]].
                1. If _scope_ is an `AssertedBlockScope` or an `AssertedScriptGlobalScope` or an `AssertedVarScope`, then
                    1. Let _enclosingDeclaredOrBoundNames_ be _enclosingScope_`.declaredNames`.
                1. Else,
                    1. Let _enclosingDeclaredOrBoundNames_ be _enclosingScope_`.boundNames`.
                1. For each _d_ in _enclosingDeclaredOrBoundNames_, do
                    1. If _fn_ is _d_`.name`, then
                        1. If _d_`.isCaptured` is *true*, then set _foundAssertedCapture_ to *true*.
                        1. Else throw a *SyntaxError* exception.
                1. If _foundAssertedCapture_ is *false*, then,
                    1. Set _outermostScope_ to _scopeNode_.
                    1. Set _scopeNode_ to _scopeNode_.[[Enclosing]].
            1. If _foundAssertedCapture_ is *false*, then
                1. NOTE: For scripts, global vars are properties on the global object and not bindings.
                1. If _outermostScope_ is not an `AssertedScriptGlobalScope`, then throw a *SyntaxError* exception.
        1. NOTE: The presence of a direct eval must have been asserted in an enclosing scope. It is permitted to assert having a direct eval even if a direct eval is never observed in scope.
        1. If _parseTree_ contains a direct eval, then
            1. Let _scopeNode_ be FindAssertedScopeTreeNode(_scope_).
            1. Let _foundAssertedDirectEval_ to be *false*.
            1. Repeat, while _scopeNode_ is not *null*,
                1. If _scopeNode_.[[AssertedScope]]`.hasDirectEval` is *true*, then set _foundAssertedDirectEval_ to *true*.
                1. Else if _foundAssertedDirectEval_ is *false*, then throw a *SyntaxError* exception.
                1. Set _scopeNode_ to _scopeNode_.[[Enclosing]].
            1. If _foundAssertedDirectEval_ is *false*, then throw a *SyntaxError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-checkthiscapture" aoid="CheckThisCapture">
      <h1>CheckThisCapture ( _scope_ , _parseTree_ )</h1>
      <emu-alg>
        1. Assert: _scope_ is an `AssertedVarScope` or an `AssertedParameterScope`.
        1. Assert: _parseTree_ is a non-empty Parse Node.
        1. If the value of HasFreeThis of _parseTree_ is *false*, then return.
        1. Let _scopeNode_ be FindAssertedScopeTreeNode(_scope_).
        1. Let _foundCapturedThis_ to be *false*.
        1. Repeat, while _scopeNode_.[[Enclosing]] is not *null* and _foundCapturedThis_ is *false*,
            1. Let _enclosingScope_ be _scopeNode_.[[Enclosing]].[[AssertedScope]].
            1. If _enclosingScope_ is an `AssertedBlockScope`, then
                1. If _enclosingScope_`.declaredNames` has a single item _d_ and _d_`.name` is `"this"`, then
                    1. If _d_`.isCaptured` is *true*, then set _foundCapturedThis_ to *true*.
                    1. Else throw a *SyntaxError* exception.
            1. Else,
                1. Set _outermostScope_ to _scopeNode_.
                1. Set _scopeNode_ to _scopeNode_.[[Enclosing]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-synthesizethisscope" aoid="SynthesizeThisScope">
      <h1>SynthesizeThisScope ( _funcNode_ , _enclosingScope_ )</h1>
      <emu-alg>
          1. NOTE: All functions except arrows may have their `this` binding captured by a nested arrow. Synthesize a scope that encloses the parameter and body scopes of the function body that contains the sole binding `this`. It is checked by CheckThisCapture.
          1. Assert: _funcNode_ is not an `EagerArrowExpression` nor a `LazyArrowExpression`.
          1. Let _synthThisScope_ be a new `AssertedBlockScope`.
          1. Let _thisDecl_ be a new `AssertedDeclaredName`.
          1. Set _thisDecl_`.name` to `"this"`.
          1. Set _thisDecl_`.kind` to `"non-const lexical"`.
          1. If _funcNode_`.contents.isThisCaptured` is *true*, then
              1. Set _thisDecl_`.isCaptured` to *true*.
          1. Set _synthThisScope_`.declaredNames` to be a new `FrozenArray&lt;AssertedDeclaredName&gt;` of length 1 containing _thisDecl_.
          1. Set _synthThisScope_`.hasDirectEval` to _enclosingScope_`.hasDirectEval`.
          1. Perform AddAssertedScopeTreeNode(_synthThisScope_, _enclosingScope_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-synthesizenamedlambdascope" aoid="SynthesizeNamedLambdaScope">
      <h1>SynthesizeNamedLambdaScope ( _funcExprNode_ , _enclosingScope_ )</h1>
      <emu-alg>
          1. NOTE: Named function expressions may capture their name, which synthesizes a block scope containing only the function name enclosing the entire function expression.
          1. Let _synthNamedLambdaScope_ be a new `AssertedBlockScope`.
          1. Let _namedLambdaDecl_ be a new `AssertedDeclaredName`.
          1. Set _namedLambdaDecl_`.name` to _funcExprNode_`.name`.
          1. NOTE: The named lambda name is not exactly a `const`, but it does not matter for the semantics of asserted scopes.
          1. Set _namedLambdaDecl_`.kind` to `"const lexical"`.
          1. Set _namedLambdaDecl_`.isCaptured` to *true*.
          1. Set _synthNamedLambdaScope_`.declaredNames` to be a new `FrozenArray&lt;AssertedDeclaredName&gt;` of length 1 containing _namedLambdaDecl_.
          1. Set _synthNamedLambdaScope_`.hasDirectEval` to _enclosingScope_`.hasDirectEval`.
          1. Perform AddAssertedScopeTreeNode(_synthNamedLambdaScope_, _enclosingScope_).
          1. Return _synthNamedLambdaScope_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-newstaticsemantics">
      <h1>Static Semantics</h1>
      <p>FreeNames is a new Static Semantics that collects uses of unbound variables.</p>

      <emu-clause id="sec-wildcard-static-semantics-freenames">
        <h1>Static Semantics: FreeNames</h1>
        <emu-see-also-para op="FreeNames"></emu-see-also-para>
        <p>Unless overridden, Parse Nodes have the following default definition.</p>
        <emu-alg>
          1. Let _freeNames_ be a new empty List.
          1. For each |IdentifierReference| contained in this Parse Node, do
              1. Let _usedName_ be the FreeNames of |IdentifierReference|.
              1. If _usedName_ is not in _freeNames_, add _usedName_ as the last element of _freeNames_.
          1. Return _freeNames_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-identifierreference-static-semantics-freenames">
        <h1>Static Semantics: FreeNames</h1>
        <emu-see-also-para op="FreeNames"></emu-see-also-para>
        <emu-grammar>IdentifierReference : `yield`</emu-grammar>
        <emu-alg>
          1. Return &laquo; `"yield"` &raquo;.
        </emu-alg>
        <emu-grammar>IdentifierReference : `await`</emu-grammar>
        <emu-alg>
          1. Return &laquo; `"await"` &raquo;.
        </emu-alg>
        <emu-grammar>IdentifierReference : Identifier</emu-grammar>
        <emu-alg>
          1. Return &laquo; StringValue of |Identifier| &raquo;.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-block-static-semantics-freenames">
        <h1>Static Semantics: FreeNames</h1>
        <emu-see-also-para op="FreeNames"></emu-see-also-para>
        <emu-grammar>Block : `{` StatementList `}`</emu-grammar>
        <emu-alg>
          1. Let _freeNames_ be the FreeNames of |StatementList|.
          1. Let _lexicallyDeclaredNames_ be the LexicallyDeclaredNames of |StatementList|.
          1. For each _dn_ in _lexicallyDeclaredNames_, do
              1. Remove _dn_ from _freeNames_.
          1. Return _freeNames_.
        </emu-alg>
        <emu-grammar>StatementList : StatementList StatementListItem</emu-grammar>
        <emu-alg>
          1. Let _freeNames_ be FreeNames of |StatementList|.
          1. Append to _freeNames_ the elements of the FreeNames of |StatementListItem|.
          1. Remove duplicate entries from _freeNames_.
          1. Return _freeNames_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-functionbody-static-semantics-freenames">
        <h1>Static Semantics: FreeNames</h1>
        <emu-see-also-para op="FreeNames"></emu-see-also-para>
        <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
        <emu-alg>
          1. Let _freeNames_ be the FreeNames of |FunctionStatementList|.
          1. Let _varDeclaredNames_ be the VarDeclaredNames of |FunctionStatementList|.
          1. For each _vn_ in _varDeclaredNames_, do
              1. Remove _vn_ from _freeNames_.
          1. Let _lexicallyDeclaredNames_ be the LexicallyDeclaredNames of |FunctionStatementList|.
          1. For each _dn_ in _lexicallyDeclaredNames_, do
              1. Remove _dn_ from _freeNames_.
          1. Return _freeNames_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-scriptbody-static-semantics-freenames">
        <h1>Static Semantics: FreeNames</h1>
        <emu-see-also-para op="FreeNames"></emu-see-also-para>
        <emu-grammar>ScriptBody : StatementList</emu-grammar>
        <emu-alg>
          1. Let _freeNames_ be the FreeNames of |StatementList|.
          1. Let _varDeclaredNames_ be the VarDeclaredNames of |StatementList|.
          1. For each _vn_ in _varDeclaredNames_, do
              1. Remove _vn_ from _freeNames_.
          1. Let _lexicallyDeclaredNames_ be the LexicallyDeclaredNames of |StatementList|.
          1. For each _dn_ in _lexicallyDeclaredNames_, do
              1. Remove _dn_ from _freeNames_.
          1. Return _freeNames_.
        </emu-alg>
      </emu-clause>

      <p>HasFreeThis is a new Static Semantics that returns *true* if `this` is free in the Parse Node (i.e. either used directly or in a nested arrow expression).</p>

      <emu-clause id="sec-wildcard-static-semantics-hasfreethis">
        <h1>Static Semantics: HasFreeThis</h1>
        <emu-see-also-para op="HasFreeThis"></emu-see-also-para>
        <p>Unless overridden, Parse Nodes have the following default definition.</p>
        <emu-alg>
          1. For each Parse Node _child_ contained in this Parse Node, do
              1. If HasFreeThis of _child_ is *true*, then return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-primaryexpression-static-semantics-hasfreethis">
        <h1>Static Semantics: HasFreeThis</h1>
        <emu-see-also-para op="HasFreeThis"></emu-see-also-para>
        <emu-grammar>PrimaryExpression : `this`</emu-grammar>
        <emu-alg>
          1. Return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hoistabledeclaration-static-semantics-hasfreethis">
        <h1>Static Semantics: HasFreeThis</h1>
        <emu-see-also-para op="HasFreeThis"></emu-see-also-para>
        <emu-grammar>HoistableDeclaration</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-functionexpression-static-semantics-hasfreethis">
        <h1>Static Semantics: HasFreeThis</h1>
        <emu-see-also-para op="HasFreeThis"></emu-see-also-para>
        <emu-grammar>FunctionExpression</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncfunctionexpression-static-semantics-hasfreethis">
        <h1>Static Semantics: HasFreeThis</h1>
        <emu-see-also-para op="HasFreeThis"></emu-see-also-para>
        <emu-grammar>AsyncFunctionExpression</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorexpression-static-semantics-hasfreethis">
        <h1>Static Semantics: HasFreeThis</h1>
        <emu-see-also-para op="HasFreeThis"></emu-see-also-para>
        <emu-grammar>AsyncGeneratorExpression</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-methoddefinition-static-semantics-hasfreethis">
        <h1>Static Semantics: HasFreeThis</h1>
        <emu-see-also-para op="HasFreeThis"></emu-see-also-para>
        <emu-grammar>MethodDefinition</emu-grammar>
        <emu-alg>
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-runjobs" aoid="RunJobs">
    <h1>RunJobs ( )</h1>
    <p>The abstract operation RunJobs is modified as follows.</p>
    <emu-alg>
      1. Perform ? InitializeHostDefinedRealm().
      1. In an implementation-dependent manner, obtain the ECMAScript source texts (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>)<ins>, ECMAScript ASTs (see <emu-xref href="#binast-tree-grammar" title></emu-xref>)</ins>, and any associated host-defined values for zero or more ECMAScript scripts<ins>,</ins> ECMAScript modules<ins>, ECMAScript `Script` ASTs, and/or ECMAScript `Module` ASTs</ins>. For each such <del>_sourceText_</del><ins>_sourceTextOrAST_</ins> and _hostDefined_, do
        1. If _sourceText_ is the source code of a script<ins> or a `Script`</ins>, then
          1. Perform EnqueueJob(`"ScriptJobs"`, ScriptEvaluationJob, &laquo; <del>_sourceText_</del><ins>_sourceTextOrAST_</ins>, _hostDefined_ &raquo;).
        1. Else _sourceText_ is the source code of a module<ins> or a `Module`</ins>,
          1. Perform EnqueueJob(`"ScriptJobs"`, TopLevelModuleEvaluationJob, &laquo; <del>_sourceText_</del><ins>_sourceTextOrAST_</ins>, _hostDefined_ &raquo;).
      1. Repeat,
        1. Suspend the running execution context and remove it from the execution context stack.
        1. Assert: The execution context stack is now empty.
        1. Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner. If all Job Queues are empty, the result is implementation-defined.
        1. Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.
        1. Let _newContext_ be a new execution context.
        1. Set _newContext_'s Function to *null*.
        1. Set _newContext_'s Realm to _nextPending_.[[Realm]].
        1. Set _newContext_'s ScriptOrModule to _nextPending_.[[ScriptOrModule]].
        1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.
        1. Perform any implementation or host environment defined job initialization using _nextPending_.
        1. Let _result_ be the result of performing the abstract operation named by _nextPending_.[[Job]] using the elements of _nextPending_.[[Arguments]] as its arguments.
        1. If _result_ is an abrupt completion, perform HostReportErrors(&laquo; _result_.[[Value]] &raquo;).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-scriptevaluationjob" aoid="ScriptEvaluationJob">
    <h1>ScriptEvaluationJob ( _sourceTextOrAST_, _hostDefined_ )</h1>
    <p>The abstract operation ScriptEvaluationJob is modified as follows.</p>
    <emu-alg>
      1. Assert: <del>_sourceText_</del><ins>_sourceTextOrAST_</ins> is an ECMAScript source text (see clause <emu-xref href="#sec-ecmascript-language-source-code"></emu-xref>)<ins> or a `Script` (see <emu-xref href="#binast-tree-grammar" title></emu-xref>)</ins>.
      1. Let _realm_ be the current Realm Record.
      1. <del>L</del><ins>If _sourceTextOrAST_ is an ECMAScript source text, then l</ins>et _s_ be ParseScript(<del>_sourceText_</del><ins>_sourceTextOrAST_</ins>, _realm_, _hostDefined_).
      1. <ins>Else let _s_ be ? TransformASTScript(_sourceTextOrAST_, _realm_, _hostDefined_).</ins>
      1. If _s_ is a List of errors or _s_, then
          1. Perform HostReportErrors(_s_).
          1. Return NormalCompletion(*undefined*).
      1. Return ? ScriptEvaluation(_s_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-transformastscript" aoid="TransformASTScript">
    <h1>TransformASTScript ( _ast_, _realm_, _hostDefined_ )</h1>
    <p>TransformASTScript is a new abstract operation.</p>
    <emu-alg>
      1. Assert: The current asserted scope to *null*.
      1. Let _body_ be ? EcmaifyScript(_ast_).
      1. Return Script Record {[[Realm]]: _realm_, [[Environment]]: *undefined*, [[ECMAScriptCode]]: _body_, [[HostDefined]]: _hostDefined_}.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-validateandupdatefunctionobject" aoid="ValidateAndUpdateFunctionObject">
    <h1>ValidateAndUpdateFunctionObject ( _funcNode_ , _functionObject_, _body0_, _params_ )</h1>
    <emu-alg>
      1. Let _prod_ be an empty Parse Node.
      1. Let _body_ be an empty Parse Node.
      1. If _funcNode_ is a `FunctionDeclaration`, then
          1. Let _funcName_ be ? Ecmaify(_funcNode_`.name`).
          1. If _funcNode_`.isAsync` is *true*, then
              1. Set _body_ toe |AsyncFunctionBody| : _body0_.
              1. Set _prod_ |AsyncFunctionDeclaration| : <emu-t>async</emu-t> <emu-t>function</emu-t> _funcName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Else if _funcNode_`.isGenerator` is *true*, then
              1. Set _body_ to |GeneratorBody| : _body0_.
              1. Set _prod_ to |GeneratorDeclaration| : <emu-t>function</emu-t> <emu-t>`*`</emu-t> _funcName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Else,
              1. Set _body_ to _body0_.
              1. Set _prod_ to |FunctionDeclaration| : <emu-t>function</emu-t> _funcName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else if _funcNode_ is an `ArrowExpression`, then
          1. If _funcNode_`.isAsync` is *true*, then
              1. Let _asyncHead_ be |AsyncArrowHead| : <emu-t>async</emu-t> _params_.
              1. Let _body1_ be |AsyncFunctionBody| : _body0_.
              1. Set _body_ to |AsyncConciseBody| : <emu-t>{</emu-t> _body1_ <emu-t>}</emu-t>.
              1. Set _prod_ to |AsyncArrowFunction| : _asyncHead_ <emu-t>=&gt;</emu-t> _body_.
          1. Else,
              1. Set _body_ to |ConciseBody| : <emu-t>{</emu-t> _body0_ <emu-t>}</emu-t>.
              1. Set _prod_ to |ArrowFunction| : _params_ <emu-t>=&gt;</emu-t> _body_.
      1. Else if _funcNode_ is a `FunctionExpression`, then
          1. Let _maybeFuncName_ be an empty Parse Node.
          1. If _funcNode_`.name` not *null*, then set _maybeFuncName_ to ? Ecmaify(_funcNode_`.name`).
          1. If _funcNode_`.isAsync` is *true*, then
              1. Set _body_ to |AsyncFunctionBody| : _body0_.
              1. Set _prod_ to |AsyncFunctionExpression| : <emu-t>async</emu-t> <emu-t>function</emu-t> _maybeFuncName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Else if _funcNode_`.isGenerator` is *true*, then
              1. Set _body_ to |GeneratorBody| : _body0_.
              1. Set _prod_ to |GeneratorExpression| : <emu-t>function</emu-t> <emu-t>`*`</emu-t> _maybeFuncName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Else,
              1. Set _body_ to _body0_.
              1. Set _prod_ to |FunctionExpression| : <emu-t>function</emu-t> _maybeFuncName_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else if _funcNode_ is a `Method`, then
          1. Let _name_ be |PropertyName| : ? Ecmaify(_funcNode_`.name`).
          1. If _funcNode_`.isAsync` is |true|, then
              1. Set _body_ to |AsyncFunctionBody| : _body0_.
              1. Let _m_ be |AsyncMethod| : <emu-t>async</emu-t> _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
              1. Set _prod_ to |MethodDefinition| : _m_.
          1. Else if _funcNode_`.isGenerator` is |true|, then
              1. Set _body_ to |GeneratorBody| : _body0_.
              1. Let _m_ |GeneratorMethod| : <emu-t>`*`</emu-t> _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
              1. Set _prod_ to |MethodDefinition| : _m_.
          1. Else,
              1. Set _body_ to _body0_.
              1. Set _prod_ to |MethodDefinition| : _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else if _funcNode_ is a `Getter`, then
          1. Let _name_ be |PropertyName| : ? Ecmaify(_funcNode_`.name`).
          1. Set _body_ to _body0_.
          1. Set _prod_ to |MethodDefinition| : <emu-t>get</emu-t> _name_ <emu-t>(</emu-t> <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else,
          1. Assert: _funcNode_ is a `Setter`.
          1. Let _name_ be |PropertyName| : ? Ecmaify(_funcNode_`.name`).
          1. Set _body_ to _body0_.
          1. Set _prod_ to |MethodDefinition| : <emu-t>set</emu-t> _name_ <emu-t>(</emu-t> _param_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Validate _prod_ for any Early Error conditions. If early errors were found, then throw a *SyntaxError* or a *ReferenceError* exception, depending on the type of the error.
      1. Set _functionObject_.[[FormalParameters]] to _params_.
      1. Set _functionObject_.[[ECMAScriptCode]] to _prod_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-runtime-semantics-delazify">
    <h1>Runtime Semantics: Delazify</h1>
    <emu-see-also-para op="Delazify"></emu-see-also-para>
    <p>Delazify is a new Runtime Semantics.</p>
    <p>With parameter _functionObject_.</p>

    <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
    <emu-alg>
      1. If |FunctionStatementList| is a |StatementList| consisting of a single |EmptyStatement| that is tagged as being produced by _funcNode_ in scope _scope_, then
          1. Assert: The current asserted scope is *null*.
          1. Set the current asserted scope to _scope_.
          1. Assert: _funcNode_ is a `LazyFunctionDeclaration`, a `LazyFunctionExpression`, a `LazyMethod`, a `LazyGetter`, a `LazySetter`, or a `LazyArrowExpression`.
          1. Let _contents_ be _funcNode_`.contents`.
          1. If _funcNode_ is a `LazyFunctionExpression`, _funcNode_`.name` is not *null*, and _contents_`.isFunctionNameCaptured` is *true*, then
              1. Set _scope_ to SynthesizeNamedLambdaScope(_funcNode_, _scope_).
          1. If _funcNode_ is not a `LazyArrowExpression`, then
              1. Set _scope_ to SynthesizeThisScope(_funcNode_, _scope_).
          1. If _funcNode_ is not a `LazyGetter`, then
              1. Perform AddAssertedScopeTreeNode(_contents_`.parameterScope`, _scope_).
              1. Set _scope_ to _contents_`.parameterScope`.
          1. Perform AddAssertedScopeTreeNode(_contents_`.bodyScope`, _scope_).
          1. Let _delazifiedParams_ be the result of Delazify on the Parse Node that is _functionObject_.[[FormalParameters]] passing _functionObject_.
          1. Set the current asserted scope to _contents_`.bodyScope`.
          1. Let _delazifiedBody_ be ? EcmaifyFunctionBody(_funcNode_).
          1. Perform ? ValidateAndUpdateFunctionObject(_funcNode_, _functionObject_, _delazifiedBody_, _delazifiedParams_).
          1. If _funcNode_ is not a `LazyGetter`, then perform ? CheckAssertedScope(_contents_`.parameterScope`, _delazifiedParams_).
          1. Perform ? CheckAssertedScope(_contents_`.bodyScope`, _delazifiedBody_).
          1. If _funcNode_ is a `LazyArrowExpression`, then
              1. Perform ? CheckThisCapture(_contents_`.parameterScope`, _delazifiedParams_).
              1. Perform ? CheckThisCapture(_contents_`.bodyScope`, _delazifiedBody_).
          1. Set the current asserted scope to *null*.
          1. Return |FunctionBody| : _delazifiedBody_.
      1. Else return |FunctionBody|.
    </emu-alg>

    <emu-grammar>FormalParameters : [empty]</emu-grammar>
    <emu-alg>
      1. If |FormalParameters| is tagged as being produced by an AST node _funcAst_, then
          1. Assert: The current asserted scope is *null*.
          1. Set the current asserted scope to _funcAst_`.contents.parameterScope`.
          1. Let _params_ be ? EcmaifyFormalParameters(_funcAst_`.contents.params`).
          1. Set the current asserted scope to *null*.
          1. Return _params_.
      1. Else return |FormalParameters|.
    </emu-alg>

    <emu-grammar>UniqueFormalParameters : FormalParameters</emu-grammar>
    <emu-alg>
      1. Let _delazifiedParams_ be the result of Delazify of |FormalParameters| passing *null*.
      1. Return |UniqueFormalParameters| : _delazifiedParams_.
    </emu-alg>

    <emu-grammar>ArrowParameters : CoverParenthesizedExpressionAndArrowParameterList</emu-grammar>
    <emu-alg>
      1. If |ArrowParameters| is tagged as being produced by an AST node _funcAst_, then
          1. Set the current asserted scope to _funcAst_`.contents.parameterScope`.
          1. Let _params_ be ? EcmaifyCoverArrowParameterList(_funcAst_`.contents.params`).
          1. Set the current asserted scope to *null*.
          1. Return _params_.
      1. Else return |ArrowParameters|.
    </emu-alg>

    <emu-grammar>PropertySetParameterList : FormalParameter</emu-grammar>
    <emu-alg>
      1. If |PropertySetParameterList| is tagged as being produced by an AST node _funcAst_, then
          1. Set the current asserted scope to _funcAst_`.contents.parameterScope`.
          1. Let _params_ be ? EcmaifyPropertySetParameterList(_funcAst_`.contents.param`).
          1. Set the current asserted scope to *null*.
          1. Return _params_.
      1. Else return |PropertySetParameterList|.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-runtime-semantics-evaluatebody">
    <h1>Runtime Semantics: EvaluateBody</h1>
    <p>The runtime semantics of |FunctionBody| is modified as follows.</p>
    <p>With parameters _functionObject_ and List _argumentsList_.</p>
    <emu-grammar>FunctionBody : FunctionStatementList</emu-grammar>
    <emu-alg>
      1. <ins>Let _delazifiedBody_ be the Parse Node that is the result of Delazify of |FunctionBody| passing _functionBody_.</ins>
      1. <ins>If _delazifiedBody_ is a different Parse Node from |FunctionBody|, then</ins>
          1. <ins>Return the result of EvaluateBody of the Parse Node that is _functionObject_.[[ECMAScriptCode]] passing _functionObject_ and _argumentsList_.</ins>
      1. <ins>Else,</ins>
          1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
          1. Return the result of evaluating |FunctionStatementList|.
    </emu-alg>

    <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
    <emu-alg>
      1. <ins>Let _delazifiedBody_ be the Parse Node that is the result of Delazify of |FunctionBody| passing _functionObject_.</ins>
      1. <ins>If _delazifiedBody_ is a different Parse Node from |FunctionBody|, then</ins>
          1. <ins>Return the result of EvaluateBody of the Parse Node that is _functionObject_.[[ECMAScriptCode]] passing _functionObject_ and _argumentsList_.</ins>
      1. <ins>Else,</ins>
          1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
          1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, `"%GeneratorPrototype%"`, &laquo; [[GeneratorState]], [[GeneratorContext]] &raquo;).
          1. Perform GeneratorStart(_G_, |FunctionBody|).
          1. Return Completion{[[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~}.
    </emu-alg>

    <emu-grammar>AsyncFunctionBody : FunctionBody</emu-grammar>
    <emu-alg>
      1. <ins>Let _delazifiedBody_ be the Parse Node that is the result of Delazify of |FunctionBody| passing _functionObject_.</ins>
      1. <ins>If _delazifiedBody_ is a different Parse Node from |FunctionBody|, then</ins>
          1. <ins>Return the result of EvaluateBody of the Parse Node that is _functionObject_.[[ECMAScriptCode]] passing _functionObject_ and _argumentsList_.</ins>
      1. <ins>Else,</ins>
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _declResult_ be FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
          1. If _declResult_ is not an abrupt completion, then
            1. Perform ! AsyncFunctionStart(_promiseCapability_, |FunctionBody|).
          1. Else _declResult_ is an abrupt completion,
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo;_declResult_.[[Value]]&raquo;).
          1. Return Completion{[[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~}.
    </emu-alg>
  </emu-clause>
</emu-clause>
